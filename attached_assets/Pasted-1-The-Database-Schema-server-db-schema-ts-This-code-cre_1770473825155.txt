1. The Database Schema (server/db/schema.ts)
This code creates the permanent record of who is allowed to do what.

Prompt to Replit: "Replace the content of server/db/schema.ts with this specific schema to handle certifications:"

TypeScript
import { pgTable, text, serial, integer, boolean, timestamp, pgEnum } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// 1. DEFINING THE SKILLS (The "Unlicensed 5")
export const skillEnum = pgEnum('skill_type', [
  'core_safety',      // Required for everyone
  'junk_removal',     // Module A
  'pressure_washing', // Module B
  'gutter_cleaning',  // Module C
  'moving_labor',     // Module D
  'home_audit'        // Module E (The Upsell)
]);

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").unique().notNull(),
  password: text("password").notNull(),
  role: text("role").default("customer"), // 'customer' or 'hauler'
  
  // GAMIFICATION & SAFETY
  xpPoints: integer("xp_points").default(0),
  currentTier: text("current_tier").default("rookie"), // rookie, pro, elite
  isVerified: boolean("is_verified").default(false),   // Background check
  
  createdAt: timestamp("created_at").defaultNow(),
});

// 2. THE CERTIFICATION TABLE (The Permanent Record)
export const certifications = pgTable("certifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  skillType: skillEnum("skill_type").notNull(),
  status: text("status").default("active"), // active, expired, revoked
  quizScore: integer("quiz_score").notNull(),
  issuedAt: timestamp("issued_at").defaultNow(),
  expiresAt: timestamp("expires_at"), // set to 1 year from issue
});

// RELATIONS
export const usersRelations = relations(users, ({ many }) => ({
  certifications: many(certifications),
}));

export const certificationsRelations = relations(certifications, ({ one }) => ({
  user: one(users, {
    fields: [certifications.userId],
    references: [users.id],
  }),
}));

// ... (Keep your existing 'services' and 'orders' tables here)
2. The "Gatekeeper" API (server/routes.ts)
This is the logic that actually processes the quiz and unlocks the badge.

Prompt to Replit: "Add this specific route to server/routes.ts to handle the Certification logic:"

TypeScript
// POST /api/academy/certify
// Receives: { userId, skillType, quizScore }
app.post("/api/academy/certify", async (req, res) => {
  try {
    const { userId, skillType, quizScore } = req.body;

    // 1. THE PASS/FAIL CHECK
    if (quizScore < 80) {
      return res.status(400).json({ 
        success: false, 
        message: "Score too low. You need 80% to certify." 
      });
    }

    // 2. CALCULATE EXPIRATION (1 Year Validity)
    const expiresAt = new Date();
    expiresAt.setFullYear(expiresAt.getFullYear() + 1);

    // 3. SAVE TO DATABASE
    const newCert = await db.insert(certifications).values({
      userId,
      skillType,
      quizScore,
      status: 'active',
      expiresAt: expiresAt
    }).returning();

    // 4. GIVE XP REWARD (+50 XP)
    // We also check if they need a Tier Upgrade here
    await db.update(users)
      .set({ 
        xpPoints: sql`${users.xpPoints} + 50`,
        // Logic: If they have Core + 2 Skills, upgrade to 'Pro'
      })
      .where(eq(users.id, userId));

    res.json({ success: true, cert: newCert[0], message: "Badge Unlocked!" });

  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});