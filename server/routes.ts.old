import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { insertServiceRequestSchema, quoteRequestSchema, locationUpdateSchema, haulerCheckInSchema, haulerProfileUpdateSchema, POINTS_PER_DOLLAR, insertBusinessAccountSchema, insertRecurringJobSchema } from "@shared/schema";
import { calculateDistance, geocodeZip, isZipCodeSupported, calculateMovePricing, findNearestDump, SUPPORTED_ZIP_CODES } from "./distanceUtils";
import { z } from "zod";
import { registerObjectStorageRoutes } from "./replit_integrations/object_storage";
import { analyzePhotosForQuote, analyzeVideoFramesForQuote, analyzePhotosForHazards, categorizeItemsForDisposal, estimateCarbonFootprint, generateBundlingSuggestions, analyzeDisputePhotos, classifyItemsForDisposal, calculateCarbonOptimizedBatches, analyzeTaxCreditEligibility, scanReceipt, getTaxCreditAlerts, calculateMoveImpact, verifyDisposalReceipt, catalogItemsForInsurance, generateResaleDescription } from "./services/ai-analysis";
import type { DispatchRoute, TaxCreditAlert } from "./services/ai-analysis";
import { stripeService } from "./stripeService";
import { analyzePhotos, getQuickEstimate } from "./photoAnalysisService";
import { setupAuth, registerAuthRoutes, isAuthenticated } from "./replit_integrations/auth";
import { requireAuth, requireAdmin, requireHauler, requireCustomer, requireOwnership } from "./auth-middleware";
import { validateReceiptWithAI, type ReceiptValidationInput } from "./services/rebate-ai-validation";
import bcrypt from "bcrypt";
import OpenAI from "openai";
import multer from "multer";
import passport from "passport";
import { sendVerificationEmail, sendPasswordResetEmail, isEmailConfigured, isSmsConfigured, sendEmail, sendSms, sendPropertyTransferEmail } from "./services/notifications";
import { passwordResetTokens, dispatchBatches, esgImpactLogs, haulerRiskProfile, chatMessages, properties, propertyEvents, propertyTransfers, consultations, deferredJobs, haulerCertifications, homeInventory, haulerProfiles } from "@shared/schema";
import { updateHomeScore, getHomeScore, getScoreLabel, getScorePercentile } from "./services/scoringService";
import { calculateServicePrice, getUpsellOpportunities, getServiceLabel } from "./services/pricing";
import { checkPromotion, addXp, getNextLevelRequirements, LEVEL_NAMES } from "./services/careerService";
import { parseInventoryFromPhotos } from "./services/inventory-ai";
import { db } from "./db";
import { eq, and, gt, sql, desc } from "drizzle-orm";
import crypto from "crypto";
import { auditMiddleware, logAuditEvent } from "./middleware/audit";
import { auditLogs, serviceRequests } from "@shared/schema";

// Contact masking helper - masks customer/hauler contact info until payment is received
interface MaskableRequest {
  paymentStatus: string | null;
  customerPhone?: string | null;
  customerEmail?: string | null;
  assignedHauler?: {
    phone?: string | null;
    email?: string | null;
    [key: string]: unknown;
  } | null;
  [key: string]: unknown;
}

function maskContactInfoForRole<T extends MaskableRequest>(
  request: T,
  role: 'customer' | 'hauler' | 'admin'
): T {
  const paymentReceived = request.paymentStatus && ["authorized", "captured", "completed"].includes(request.paymentStatus);
  
  if (paymentReceived || role === 'admin') {
    return request; // Admin always sees everything, others see after payment
  }
  
  const result = { ...request };
  
  // Customers can't see PYCKER contact info until payment
  if (role === 'customer' && result.assignedHauler) {
    result.assignedHauler = {
      ...result.assignedHauler,
      phone: null,
      email: null,
    };
  }
  
  // PYCKERs can't see customer contact info until payment
  if (role === 'hauler') {
    result.customerPhone = null;
    result.customerEmail = null;
  }
  
  return result;
}

async function triggerAIValidation(claimId: string, input: ReceiptValidationInput): Promise<void> {
  try {
    console.log(`Starting AI validation for rebate claim ${claimId}...`);
    const result = await validateReceiptWithAI(input);
    
    await storage.updateRebateClaimAIValidation(claimId, {
      aiValidationStatus: result.status,
      aiValidationResult: JSON.stringify(result.details),
      aiValidationNotes: result.notes,
      aiValidatedAt: new Date().toISOString(),
      aiConfidenceScore: result.confidenceScore,
    });
    
    console.log(`AI validation completed for claim ${claimId}: ${result.status} (${result.confidenceScore}% confidence)`);
  } catch (error) {
    console.error(`AI validation failed for claim ${claimId}:`, error);
    await storage.updateRebateClaimAIValidation(claimId, {
      aiValidationStatus: "needs_review",
      aiValidationNotes: "AI validation failed - manual review required",
      aiValidatedAt: new Date().toISOString(),
      aiConfidenceScore: 0,
    });
  }
}

const jobConnections = new Map<string, Set<WebSocket>>();
const wsConnectionMeta = new WeakMap<WebSocket, { role?: string; jobId?: string; userId?: string }>();

function broadcastToJob(jobId: string, message: object) {
  const connections = jobConnections.get(jobId);
  if (connections) {
    const data = JSON.stringify(message);
    connections.forEach(ws => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(data);
      }
    });
  }
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  
  // Setup authentication BEFORE registering routes
  await setupAuth(app);
  registerAuthRoutes(app);
  
  registerObjectStorageRoutes(app);
  
  app.use(auditMiddleware);
  
  // DISABLED: No longer seeding fake PYCKER data
  // await storage.seedInitialData();
  await storage.seedOrlando25PromoCode();
  
  const wss = new WebSocketServer({ server: httpServer, path: "/ws" });
  
  wss.on("connection", (ws, req) => {
    const url = new URL(req.url || "", `http://${req.headers.host}`);
    const jobId = url.searchParams.get("jobId");
    const userId = url.searchParams.get("userId");
    const role = url.searchParams.get("role") || undefined;
    
    wsConnectionMeta.set(ws, { role, jobId: jobId || undefined, userId: userId || undefined });
    
    if (jobId) {
      if (!jobConnections.has(jobId)) {
        jobConnections.set(jobId, new Set());
      }
      jobConnections.get(jobId)!.add(ws);
      
      ws.send(JSON.stringify({ type: "connected", jobId, role }));
    }
    
    ws.on("message", async (data) => {
      try {
        const message = JSON.parse(data.toString());
        
        if (message.type === "location_update" && userId) {
          const connMeta = wsConnectionMeta.get(ws);
          if (connMeta?.role !== "hauler" || connMeta?.userId !== userId) {
            return;
          }
          
          const location = locationUpdateSchema.parse(message.data);
          await storage.addLocationHistory({
            userId,
            jobId: jobId || undefined,
            lat: location.lat,
            lng: location.lng,
            accuracy: location.accuracy,
            heading: location.heading,
            speed: location.speed,
            recordedAt: new Date().toISOString(),
          });
          
          if (jobId) {
            broadcastToJob(jobId, {
              type: "location_updated",
              userId,
              role: "hauler",
              ...location,
              timestamp: new Date().toISOString(),
            });

            // GHOST BUSTER: Auto-detect arrival via geofence (within 0.1 miles / ~500ft)
            try {
              const job = await storage.getServiceRequest(jobId);
              if (job && job.pickupLat && job.pickupLng && !job.arrivedAt) {
                const dist = haversineDistance(location.lat, location.lng, job.pickupLat, job.pickupLng);
                if (dist < 0.1) {
                  await storage.updateServiceRequest(jobId, {
                    arrivedAt: new Date().toISOString(),
                    status: "arrived",
                  });
                  broadcastToJob(jobId, { type: "worker_arrived", jobId, arrivedAt: new Date().toISOString() });
                }
              }
            } catch (geoErr) {
              console.error("Geofence check error:", geoErr);
            }
          }
        }
        
        if (message.type === "customer_location_update" && jobId) {
          const connMeta = wsConnectionMeta.get(ws);
          if (connMeta?.role !== "customer" || connMeta?.jobId !== jobId) {
            return;
          }
          
          const customerLocationSchema = z.object({
            lat: z.number().min(-90).max(90),
            lng: z.number().min(-180).max(180),
            accuracy: z.number().min(0).max(10000).nullable().optional(),
          });
          const parseResult = customerLocationSchema.safeParse(message.data);
          if (parseResult.success) {
            broadcastToJob(jobId, {
              type: "customer_location_updated",
              ...parseResult.data,
              timestamp: new Date().toISOString(),
            });
          }
        }
        // SAFECOMMS: Chat message with privacy firewall
        if (message.type === "send_message" && jobId && userId) {
          const phoneRegex = /(\+?1[ -]?)?\(?\d{3}\)?[ -]?\d{3}[ -]?\d{4}/g;
          const leakageKeywords = /venmo|cash\s*app|zelle|cancel.*app|my\s*number|phone\s*number/i;

          let finalContent = message.content || "";
          let isRedacted = false;

          if (phoneRegex.test(finalContent)) {
            finalContent = finalContent.replace(phoneRegex, "[NUMBER REDACTED FOR SAFETY]");
            isRedacted = true;
          }

          if (leakageKeywords.test(message.content || "")) {
            console.warn(`[LEAKAGE ALERT] User ${userId} mentioned payment keywords in job ${jobId}.`);
            await db.execute(sql`
              INSERT INTO hauler_risk_profile (id, hauler_id, keywords_detected, risk_score, last_incident_at)
              VALUES (gen_random_uuid(), ${userId}, 1, 10, ${new Date().toISOString()})
              ON CONFLICT (hauler_id)
              DO UPDATE SET
                keywords_detected = hauler_risk_profile.keywords_detected + 1,
                risk_score = hauler_risk_profile.risk_score + 10,
                last_incident_at = ${new Date().toISOString()}
            `);
          }

          await db.insert(chatMessages).values({
            jobId,
            senderId: userId,
            content: finalContent,
            isRedacted,
            sentAt: new Date().toISOString(),
          });

          broadcastToJob(jobId, {
            type: "receive_message",
            senderId: userId,
            content: finalContent,
            timestamp: new Date().toISOString(),
            isRedacted,
          });
        }
      } catch (error) {
        console.error("WebSocket message error:", error);
      }
    });
    
    ws.on("close", () => {
      if (jobId) {
        jobConnections.get(jobId)?.delete(ws);
        if (jobConnections.get(jobId)?.size === 0) {
          jobConnections.delete(jobId);
        }
      }
    });
  });
  
  app.get("/api/property/zillow", async (req, res) => {
    try {
      const address = req.query.address as string;
      if (!address || address.trim().length < 5) {
        return res.status(400).json({ error: "Address is required" });
      }

      // === Census Bureau geocoder for property estimation ===
      try {
        const censusParams = new URLSearchParams({
          address: address,
          benchmark: "Public_AR_Current",
          vintage: "Current_Current",
          format: "json",
        });
        const censusRes = await fetch(
          `https://geocoding.geo.census.gov/geocoder/geographies/onelineaddress?${censusParams}`
        );
        if (censusRes.ok) {
          const censusData = await censusRes.json();
          const match = censusData?.result?.addressMatches?.[0];
          if (match) {
            const geographies = match.geographies;
            const tract = geographies?.["Census Tracts"]?.[0];
            const county = geographies?.["Counties"]?.[0];
            const state = match.addressComponents?.state || "";
            const zip = match.addressComponents?.zip || "";
            const countyName = county?.NAME || "";

            const FL_COUNTY_MEDIANS: Record<string, number> = {
              "Orange": 380000, "Seminole": 395000, "Osceola": 340000,
              "Lake": 340000, "Volusia": 315000, "Brevard": 330000,
              "Polk": 290000, "Hillsborough": 370000, "Pinellas": 350000,
              "Pasco": 310000, "Manatee": 400000, "Sarasota": 450000,
              "Lee": 370000, "Collier": 550000, "Palm Beach": 470000,
              "Broward": 420000, "Miami-Dade": 490000, "Duval": 290000,
              "St. Johns": 430000, "Clay": 310000, "Alachua": 290000,
              "Leon": 265000, "Escambia": 245000, "Santa Rosa": 340000,
              "Bay": 310000, "Okaloosa": 380000, "Walton": 520000,
              "Marion": 260000, "Sumter": 320000, "Hernando": 295000,
              "Citrus": 270000, "Charlotte": 320000, "St. Lucie": 340000,
              "Martin": 430000, "Indian River": 360000, "Flagler": 340000,
            };

            let estimatedValue = 350000;
            const matchedCounty = Object.keys(FL_COUNTY_MEDIANS).find(
              (c) => countyName.toLowerCase().includes(c.toLowerCase())
            );
            if (matchedCounty) {
              estimatedValue = FL_COUNTY_MEDIANS[matchedCounty];
            }

            const zipNum = parseInt(zip, 10);
            if (zipNum >= 32800 && zipNum <= 32899) estimatedValue *= 1.05;
            if (zipNum >= 33100 && zipNum <= 33199) estimatedValue *= 1.15;
            if (zipNum >= 34200 && zipNum <= 34299) estimatedValue *= 1.10;

            estimatedValue = Math.round(estimatedValue / 1000) * 1000;

            const rentEstimate = Math.round(estimatedValue * 0.006);

            return res.json({
              found: true,
              property: {
                zpid: null,
                address: match.matchedAddress || address,
                zestimate: estimatedValue,
                rentZestimate: rentEstimate,
                bedrooms: 3,
                bathrooms: 2,
                livingArea: Math.round(estimatedValue / 220),
                lotAreaValue: null,
                lotAreaUnit: null,
                yearBuilt: null,
                homeType: "SINGLE_FAMILY",
                homeStatus: null,
                imgSrc: null,
                latitude: match.coordinates?.y || null,
                longitude: match.coordinates?.x || null,
                source: "census_estimate",
                county: countyName,
                state: state,
              },
            });
          }
        }
      } catch (censusErr) {
        console.log("[Property] Census fallback error:", censusErr);
      }

      return res.json({ found: false, message: "No property found at this address" });
    } catch (error) {
      console.error("[Property] Error:", error);
      res.status(500).json({ error: "Property valuation lookup failed" });
    }
  });

  app.get("/api/haulers", async (req, res) => {
    try {
      const haulers = await storage.getAllHaulers();
      res.json(haulers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch haulers" });
    }
  });

  app.get("/api/haulers/available", async (req, res) => {
    try {
      const haulers = await storage.getAvailableHaulers();
      res.json(haulers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch available haulers" });
    }
  });

  app.get("/api/haulers/available/with-vehicles", async (req, res) => {
    try {
      const preferVerifiedPro = req.query.preferVerifiedPro === "true";
      let haulers = await storage.getAvailableHaulersWithVehicles();
      
      // Filter to only Verified Pro PYCKERs if customer prefers
      if (preferVerifiedPro) {
        haulers = haulers.filter(h => h.profile.pyckerTier === "verified_pro");
      }
      
      res.json(haulers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch available haulers with vehicles" });
    }
  });

  app.get("/api/haulers/search", async (req, res) => {
    try {
      const { serviceType, capability, laborOnly, availableOnly } = req.query;
      const result = await storage.searchHaulers({
        serviceType: serviceType as string | undefined,
        capability: capability as string | undefined,
        laborOnly: laborOnly === "true",
        availableOnly: availableOnly !== "false",
      });
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: "Failed to search haulers" });
    }
  });

  app.get("/api/verify-badge/:badgeId", async (req, res) => {
    try {
      const { badgeId } = req.params;
      const idMatch = badgeId.replace(/[^a-zA-Z0-9-]/g, "").toUpperCase();
      
      const allProfiles = await storage.getAllHaulerProfiles();
      const match = allProfiles.find(p => {
        const shortId = (p.id || "").slice(-3).toUpperCase();
        return idMatch === `PYCK-${shortId}` || idMatch === shortId;
      });

      if (!match) {
        return res.status(404).json({ error: "Badge not found" });
      }

      const serviceLabels: Record<string, string> = {
        junk_removal: "Junk Removal",
        furniture_moving: "Furniture Moving",
        pressure_washing: "Pressure Washing",
        gutter_cleaning: "Gutter Cleaning",
        moving_labor: "Moving Labor",
        home_consultation: "Home Consultation",
      };
      const services = (match.serviceTypes || []).map(s => serviceLabels[s] || s);
      
      const displayName = match.companyName
        ? `${match.companyName.charAt(0)}. ${(match.companyName.split(" ").slice(1).join(" ") || "").charAt(0) || ""}`.trim().replace(/\.$/, "")
        : "Certified PYCKER";

      res.json({
        name: displayName || "Certified PYCKER",
        specialty: services[0] || "General Services",
        rating: match.rating || 5.0,
        verified: match.verified || false,
        tier: match.pyckerTier || "independent",
      });
    } catch (error) {
      res.status(500).json({ error: "Verification failed" });
    }
  });

  // Auth route - check username availability
  app.get("/api/auth/check-username", async (req, res) => {
    try {
      const username = req.query.username as string;
      if (!username || username.length < 3) {
        return res.json({ available: false });
      }
      const existingUser = await storage.getUserByUsername(username);
      res.json({ available: !existingUser });
    } catch (error) {
      res.status(500).json({ error: "Failed to check username" });
    }
  });

  // Auth route - send verification code to email (uses database storage)
  app.post("/api/auth/send-verification", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email || !z.string().email().safeParse(email).success) {
        return res.status(400).json({ error: "Valid email required" });
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ error: "An account with this email already exists" });
      }

      const code = Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

      // Store in database
      await storage.createEmailVerificationCode(email, code, expiresAt);

      console.log(`[EMAIL VERIFICATION] Code for ${email}: ${code}`);

      // Send actual email if configured
      let emailSent = false;
      if (isEmailConfigured()) {
        const result = await sendVerificationEmail(email, code);
        emailSent = result.success;
        if (!result.success) {
          console.warn(`Email sending failed: ${result.error}`);
        }
      }

      res.json({ 
        success: true, 
        message: emailSent ? "Verification code sent to your email" : "Verification code generated (email service not configured)",
        emailSent,
        ...(process.env.NODE_ENV === "development" ? { devCode: code } : {}),
      });
    } catch (error) {
      console.error("Error sending verification:", error);
      res.status(500).json({ error: "Failed to send verification code" });
    }
  });

  // Auth route - verify email code (uses database storage)
  app.post("/api/auth/verify-email", async (req, res) => {
    try {
      const { email, code } = req.body;
      if (!email || !code) {
        return res.status(400).json({ error: "Email and code required" });
      }

      const stored = await storage.getEmailVerificationCode(email);
      if (!stored) {
        return res.status(400).json({ error: "No verification code found. Please request a new one." });
      }

      if (new Date() > stored.expiresAt) {
        await storage.deleteEmailVerificationCode(email);
        return res.status(400).json({ error: "Verification code expired. Please request a new one." });
      }

      if (stored.code !== code) {
        return res.status(400).json({ error: "Invalid verification code" });
      }

      // Mark as verified in database
      await storage.markEmailVerified(email);
      res.json({ verified: true, message: "Email verified successfully" });
    } catch (error) {
      res.status(500).json({ error: "Failed to verify email" });
    }
  });

  // Legacy hauler routes - redirect to auth routes for consistency
  app.post("/api/haulers/check-username", async (req, res) => {
    const { username } = req.body;
    if (!username || username.length < 3) {
      return res.status(400).json({ error: "Username must be at least 3 characters" });
    }
    const existingUser = await storage.getUserByUsername(username);
    res.json({ available: !existingUser });
  });

  app.post("/api/haulers/send-verification", async (req, res) => {
    // Forward to auth route
    try {
      const { email } = req.body;
      if (!email || !z.string().email().safeParse(email).success) {
        return res.status(400).json({ error: "Valid email required" });
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ error: "An account with this email already exists" });
      }

      const code = Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000);

      await storage.createEmailVerificationCode(email, code, expiresAt);
      console.log(`[EMAIL VERIFICATION] Code for ${email}: ${code}`);

      // Send actual email if configured
      let emailSent = false;
      if (isEmailConfigured()) {
        const result = await sendVerificationEmail(email, code);
        emailSent = result.success;
        if (!result.success) {
          console.warn(`Email sending failed: ${result.error}`);
        }
      }

      res.json({ 
        success: true, 
        message: emailSent ? "Verification code sent to your email" : "Verification code generated (email service not configured)",
        emailSent,
        ...(process.env.NODE_ENV === "development" ? { devCode: code } : {}),
      });
    } catch (error) {
      console.error("Error sending verification:", error);
      res.status(500).json({ error: "Failed to send verification code" });
    }
  });

  app.post("/api/haulers/verify-email", async (req, res) => {
    try {
      const { email, code } = req.body;
      if (!email || !code) {
        return res.status(400).json({ error: "Email and code required" });
      }

      const stored = await storage.getEmailVerificationCode(email);
      if (!stored) {
        return res.status(400).json({ error: "No verification code found. Please request a new one." });
      }

      if (new Date() > stored.expiresAt) {
        await storage.deleteEmailVerificationCode(email);
        return res.status(400).json({ error: "Verification code expired. Please request a new one." });
      }

      if (stored.code !== code) {
        return res.status(400).json({ error: "Invalid verification code" });
      }

      await storage.markEmailVerified(email);
      res.json({ verified: true, message: "Email verified successfully" });
    } catch (error) {
      res.status(500).json({ error: "Failed to verify email" });
    }
  });

  // Test notification endpoints
  app.get("/api/test/email", async (req, res) => {
    const testEmail = req.query.to as string || "test@example.com";
    if (!isEmailConfigured()) {
      return res.json({ 
        success: false, 
        error: "SendGrid not configured - please add SENDGRID_API_KEY secret",
        configured: false 
      });
    }
    const result = await sendEmail({
      to: testEmail,
      subject: "UpTend Test Email",
      html: "<h1>Test Email</h1><p>Your UpTend email integration is working!</p>",
      text: "Test Email - Your UpTend email integration is working!",
    });
    res.json({ ...result, configured: true });
  });

  app.get("/api/test/sms", async (req, res) => {
    const testPhone = req.query.to as string;
    if (!testPhone) {
      return res.status(400).json({ error: "Please provide ?to=+1234567890 phone number" });
    }
    if (!isSmsConfigured()) {
      return res.json({ 
        success: false, 
        error: "Twilio not configured - please add TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, and TWILIO_PHONE_NUMBER secrets",
        configured: false 
      });
    }
    const result = await sendSms({
      to: testPhone,
      message: "UpTend Test SMS - Your SMS integration is working!",
    });
    res.json({ ...result, configured: true });
  });

  app.get("/api/test/both", async (req, res) => {
    res.json({
      email: { configured: isEmailConfigured() },
      sms: { configured: isSmsConfigured() },
    });
  });

  app.post("/api/haulers/register", async (req, res) => {
    try {
      const parsed = pyckerRegistrationSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid registration data", details: parsed.error.issues });
      }

      const data = parsed.data;

      // Check if email was verified using database storage
      const storedVerification = await storage.getEmailVerificationCode(data.email);
      if (!storedVerification || !storedVerification.verified) {
        return res.status(400).json({ error: "Please verify your email before registering" });
      }
      
      if (new Date() > storedVerification.expiresAt) {
        await storage.deleteEmailVerificationCode(data.email);
        return res.status(400).json({ error: "Email verification expired. Please verify your email again." });
      }
      
      // Check for existing email
      const existingEmail = await storage.getUserByEmail(data.email);
      if (existingEmail) {
        return res.status(400).json({ error: "An account with this email already exists" });
      }

      const hashedPassword = await bcrypt.hash(data.password, 10);

      await storage.deleteEmailVerificationCode(data.email);

      const user = await storage.createUser({
        username: data.email,
        password: hashedPassword,
        firstName: data.firstName,
        lastName: data.lastName,
        role: "hauler",
        email: data.email,
        phone: data.phone,
      });

      const vehicleCapacity = data.vehicleType === "pickup" || data.vehicleType === "cargo_van" ? "medium" :
                              data.vehicleType === "box_truck_small" ? "large" : "extra_large";

      const registrationDetails = JSON.stringify({
        streetAddress: data.streetAddress,
        city: data.city,
        state: data.state,
        zipCode: data.zipCode,
        vehicleYear: data.vehicleYear,
        vehicleMake: data.vehicleMake,
        vehicleModel: data.vehicleModel,
        licensePlate: data.licensePlate,
        driversLicense: data.driversLicense,
        insuranceProvider: data.insuranceProvider,
        insurancePolicyNumber: data.insurancePolicyNumber,
        aboutYou: data.aboutYou,
        submittedAt: new Date().toISOString(),
      });

      const profile = await storage.createHaulerProfile({
        userId: user.id,
        companyName: data.companyName,
        vehicleType: data.vehicleType,
        capacity: vehicleCapacity,
        bio: registrationDetails,
        rating: 5.0,
        reviewCount: 0,
        hourlyRate: 50,
        isAvailable: false,
        backgroundCheckStatus: "pending",
        hasCardOnFile: false,
        canAcceptJobs: false,
        profilePhotoUrl: data.profilePhotoUrl || null,
        driversLicensePhotoUrl: data.driversLicensePhotoUrl || null,
      });

      // Create vehicles from registration data
      const vehicles = (req.body.vehicles as any[]) || [];
      const createdVehicles = [];
      
      for (const v of vehicles) {
        const vehicle = await storage.createPyckerVehicle({
          haulerProfileId: profile.id,
          vehicleType: v.vehicleType,
          vehicleName: v.vehicleName || `${v.make || ''} ${v.model || ''}`.trim() || v.vehicleType,
          year: v.year,
          make: v.make,
          model: v.model,
          licensePlate: v.licensePlate,
          capacity: v.capacity || "medium",
          isEnclosed: v.isEnclosed || false,
          hasTrailer: v.hasTrailer || false,
          trailerSize: v.trailerSize,
          bedLength: v.bedLength,
          description: v.description,
          createdAt: new Date().toISOString(),
          photoUrls: v.photoUrls || [],
        });
        createdVehicles.push(vehicle);
      }

      // If no vehicles were provided in array, create one from legacy fields
      if (vehicles.length === 0 && data.vehicleType) {
        const vehicle = await storage.createPyckerVehicle({
          haulerProfileId: profile.id,
          vehicleType: data.vehicleType,
          vehicleName: `${data.vehicleMake || ''} ${data.vehicleModel || ''}`.trim() || data.vehicleType,
          year: data.vehicleYear,
          make: data.vehicleMake,
          model: data.vehicleModel,
          licensePlate: data.licensePlate,
          capacity: vehicleCapacity,
          isEnclosed: false,
          hasTrailer: false,
          createdAt: new Date().toISOString(),
        });
        createdVehicles.push(vehicle);
      }

      res.json({
        success: true,
        message: "Registration successful. Background check pending.",
        userId: user.id,
        profileId: profile.id,
        vehicles: createdVehicles,
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ error: "Failed to complete registration" });
    }
  });

  // PYCKER Login endpoint - validates hauler role
  app.post("/api/haulers/login", async (req, res, next) => {
    passport.authenticate("local", async (err: any, user: any, info: any) => {
      if (err) {
        return res.status(500).json({ error: "Login failed" });
      }
      if (!user) {
        return res.status(401).json({ error: info?.message || "Invalid credentials" });
      }
      
      // Validate that this is a hauler/PYCKER account
      const fullUser = await storage.getUser(user.userId);
      if (fullUser?.role !== "hauler" && fullUser?.role !== "admin") {
        return res.status(401).json({ error: "Please use the customer login" });
      }
      
      req.login(user, (loginErr) => {
        if (loginErr) {
          return res.status(500).json({ error: "Login failed" });
        }
        return res.json({ 
          success: true, 
          message: "Login successful",
          role: fullUser?.role,
        });
      });
    })(req, res, next);
  });

  // PYCKER Logout endpoint
  app.post("/api/haulers/logout", (req, res) => {
    req.logout((err) => {
      if (err) {
        return res.status(500).json({ error: "Logout failed" });
      }
      res.json({ success: true, message: "Logged out successfully" });
    });
  });

  // Customer: Find nearby available PYCKERs with vehicle type and capability filtering
  app.get("/api/pyckers/nearby", async (req, res) => {
    try {
      const { lat, lng, radius, vehicleType, capabilities } = req.query;
      
      if (!lat || !lng) {
        return res.status(400).json({ error: "Customer location (lat, lng) is required" });
      }

      const latitude = parseFloat(lat as string);
      const longitude = parseFloat(lng as string);
      const radiusMiles = parseFloat(radius as string) || 25; // Default 25 mile radius

      if (isNaN(latitude) || isNaN(longitude)) {
        return res.status(400).json({ error: "Invalid coordinates" });
      }

      let nearbyPyckers = await storage.getOnlinePyckersNearby(latitude, longitude, radiusMiles);

      // Filter by vehicle type if provided
      if (vehicleType) {
        nearbyPyckers = nearbyPyckers.filter((p: any) => p.vehicle_type === vehicleType);
      }

      // Filter by capabilities if provided (comma-separated list)
      if (capabilities) {
        const requiredCapabilities = (capabilities as string).split(',').map(c => c.trim());
        nearbyPyckers = nearbyPyckers.filter((p: any) => {
          const pyckerCapabilities = p.capabilities || [];
          return requiredCapabilities.every(cap => pyckerCapabilities.includes(cap));
        });
      }

      // Calculate ETA and include all vehicle/profile data
      const pyckersWithEta = nearbyPyckers.map((pycker: any) => ({
        id: pycker.pycker_id || pycker.profile_id,
        pyckerId: pycker.pycker_id || pycker.profile_id,
        latitude: pycker.latitude,
        longitude: pycker.longitude,
        status: pycker.status,
        distance: pycker.distance,
        eta: Math.round(pycker.distance / 0.5),
        etaMinutes: Math.round(pycker.distance / 30 * 60),
        location: {
          latitude: parseFloat(pycker.latitude) || 0,
          longitude: parseFloat(pycker.longitude) || 0,
        },
        // Include all hauler profile data directly
        company_name: pycker.company_name,
        first_name: pycker.first_name,
        last_name: pycker.last_name,
        profile_photo: pycker.profile_image_url,
        rating: pycker.rating,
        total_jobs: pycker.jobs_completed,
        pycker_tier: pycker.pycker_tier,
        vehicle_type: pycker.vehicle_type,
        capabilities: pycker.capabilities,
        offers_labor_only: pycker.offers_labor_only,
        capacity: pycker.capacity,
        hourly_rate: pycker.hourly_rate,
        // Also include nested haulerProfile for backward compatibility
        haulerProfile: {
          id: pycker.profile_id,
          companyName: pycker.company_name,
          rating: pycker.rating,
          reviewCount: pycker.review_count,
          isAvailable: pycker.is_available,
          pyckerTier: pycker.pycker_tier,
          vehicleType: pycker.vehicle_type,
          capabilities: pycker.capabilities,
          offersLaborOnly: pycker.offers_labor_only,
          capacity: pycker.capacity,
          hourlyRate: pycker.hourly_rate,
        },
      }));

      res.json({ 
        pyckers: pyckersWithEta,
        customerLocation: { lat: latitude, lng: longitude },
        searchRadiusMiles: radiusMiles,
      });
    } catch (error) {
      console.error("Find nearby pyckers error:", error);
      res.status(500).json({ error: "Failed to find nearby PYCKERs" });
    }
  });

  // Customer Registration endpoint
  app.post("/api/customers/register", async (req, res) => {
    try {
      const { email, password, firstName, lastName, phone, smsOptIn } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      
      if (!phone || phone.trim().length < 10) {
        return res.status(400).json({ error: "A valid phone number is required for booking updates" });
      }
      
      if (!smsOptIn) {
        return res.status(400).json({ error: "You must agree to receive SMS notifications to register" });
      }
      
      const existingEmail = await storage.getUserByEmail(email);
      if (existingEmail) {
        return res.status(400).json({ error: "Email already registered" });
      }
      
      const hashedPassword = await bcrypt.hash(password, 10);
      
      const user = await storage.createUser({
        id: crypto.randomUUID(),
        username: email,
        email,
        password: hashedPassword,
        firstName: firstName || null,
        lastName: lastName || null,
        phone: phone || null,
        role: "customer",
      });
      
      // Auto-login after registration - wait for session to be established before responding
      req.login({ 
        localAuth: true, 
        userId: user.id, 
        role: "customer" 
      }, (loginErr) => {
        if (loginErr) {
          console.error("Auto-login failed:", loginErr);
          return res.status(500).json({ error: "Registration succeeded but login failed. Please try logging in." });
        }
        
        res.json({
          success: true,
          message: "Registration successful",
          userId: user.id,
          requiresPaymentSetup: true,
        });
      });
    } catch (error) {
      console.error("Customer registration error:", error);
      res.status(500).json({ error: "Failed to complete registration" });
    }
  });

  // Customer Login endpoint - validates customer role
  app.post("/api/customers/login", async (req, res, next) => {
    passport.authenticate("local", async (err: any, user: any, info: any) => {
      if (err) {
        return res.status(500).json({ error: "Login failed" });
      }
      if (!user) {
        return res.status(401).json({ error: info?.message || "Invalid credentials" });
      }
      
      // Validate that this is a customer account
      const fullUser = await storage.getUser(user.userId);
      if (fullUser?.role !== "customer") {
        return res.status(401).json({ error: "Please use the PYCKER login portal" });
      }
      
      req.login(user, (loginErr) => {
        if (loginErr) {
          return res.status(500).json({ error: "Login failed" });
        }
        return res.json({ 
          success: true, 
          message: "Login successful",
          role: user.role,
          hasPaymentMethod: !!fullUser?.stripeCustomerId,
        });
      });
    })(req, res, next);
  });

  // Customer Logout endpoint
  app.post("/api/customers/logout", (req, res) => {
    req.logout((err) => {
      if (err) {
        return res.status(500).json({ error: "Logout failed" });
      }
      res.json({ success: true, message: "Logged out successfully" });
    });
  });

  // Admin authentication endpoints
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { password } = req.body;
      
      if (!password) {
        return res.status(400).json({ error: "Password is required" });
      }
      
      const adminPassword = process.env.ADMIN_PASSWORD;
      
      if (!adminPassword) {
        console.error("ADMIN_PASSWORD not configured");
        return res.status(500).json({ error: "Admin login not configured" });
      }
      
      // Compare passwords securely
      let isValid = false;
      if (adminPassword.startsWith('$2b$') || adminPassword.startsWith('$2a$')) {
        // Password is already stored as bcrypt hash - compare securely
        isValid = await bcrypt.compare(password, adminPassword);
      } else {
        // For plaintext stored password, use constant-time comparison
        // Pad both strings to prevent timing attacks based on string length
        const maxLen = Math.max(password.length, adminPassword.length, 64);
        const paddedInput = password.padEnd(maxLen, '\0');
        const paddedExpected = adminPassword.padEnd(maxLen, '\0');
        
        try {
          isValid = crypto.timingSafeEqual(
            Buffer.from(paddedInput, 'utf8'),
            Buffer.from(paddedExpected, 'utf8')
          );
        } catch {
          isValid = false;
        }
      }
      
      if (!isValid) {
        return res.status(401).json({ error: "Invalid password" });
      }
      
      // Set admin session
      (req.session as any).isAdmin = true;
      (req.session as any).adminLoginAt = new Date().toISOString();
      
      res.json({ success: true, message: "Admin login successful" });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(500).json({ error: "Login failed" });
    }
  });
  
  app.get("/api/admin/check", (req, res) => {
    const isAdmin = (req.session as any)?.isAdmin === true;
    res.json({ isAdmin });
  });
  
  app.post("/api/admin/logout", (req, res) => {
    (req.session as any).isAdmin = false;
    res.json({ success: true });
  });

  // Password reset rate limiting
  const passwordResetAttempts = new Map<string, { count: number; resetAt: number }>();
  const RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes
  const MAX_RESET_ATTEMPTS = 3; // Max 3 attempts per 15 minutes
  
  function checkPasswordResetRateLimit(identifier: string): boolean {
    const now = Date.now();
    const entry = passwordResetAttempts.get(identifier);
    
    if (!entry || now > entry.resetAt) {
      passwordResetAttempts.set(identifier, { count: 1, resetAt: now + RATE_LIMIT_WINDOW });
      return true;
    }
    
    if (entry.count >= MAX_RESET_ATTEMPTS) {
      return false;
    }
    
    entry.count++;
    return true;
  }

  // Password reset endpoints
  app.post("/api/auth/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      
      // Rate limit by IP and email
      const clientIp = req.ip || req.socket.remoteAddress || 'unknown';
      const ipAllowed = checkPasswordResetRateLimit(`ip:${clientIp}`);
      const emailAllowed = checkPasswordResetRateLimit(`email:${email.toLowerCase()}`);
      
      if (!ipAllowed || !emailAllowed) {
        return res.status(429).json({ error: "Too many password reset requests. Please try again in 15 minutes." });
      }
      
      const user = await storage.getUserByEmail(email);
      
      // Always return success to prevent email enumeration
      if (!user) {
        return res.json({ success: true, message: "If an account exists with that email, you will receive a password reset link." });
      }
      
      // Generate a secure token (raw for email, hashed for storage)
      const rawToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(rawToken).digest('hex');
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now
      
      // Invalidate any existing tokens for this user
      await db.update(passwordResetTokens)
        .set({ used: true })
        .where(eq(passwordResetTokens.userId, user.id));
      
      // Save the hashed token
      await db.insert(passwordResetTokens).values({
        userId: user.id,
        token: hashedToken,
        expiresAt,
        used: false,
      });
      
      // Build the reset link (use raw token in email, not hashed)
      const baseUrl = req.headers.origin || `${req.protocol}://${req.get('host')}`;
      const resetLink = `${baseUrl}/reset-password?token=${rawToken}`;
      
      // Send the email
      const emailResult = await sendPasswordResetEmail(email, resetLink);
      
      if (!emailResult.success) {
        console.error("Failed to send password reset email:", emailResult.error);
      }
      
      res.json({ success: true, message: "If an account exists with that email, you will receive a password reset link." });
    } catch (error) {
      console.error("Forgot password error:", error);
      res.status(500).json({ error: "Failed to process password reset request" });
    }
  });
  
  app.post("/api/auth/reset-password", async (req, res) => {
    try {
      const { token, password } = req.body;
      
      if (!token || !password) {
        return res.status(400).json({ error: "Token and new password are required" });
      }
      
      if (password.length < 8) {
        return res.status(400).json({ error: "Password must be at least 8 characters long" });
      }
      
      // Hash the incoming token to compare with stored hash
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
      
      // Find the token
      const [resetToken] = await db
        .select()
        .from(passwordResetTokens)
        .where(
          and(
            eq(passwordResetTokens.token, hashedToken),
            eq(passwordResetTokens.used, false),
            gt(passwordResetTokens.expiresAt, new Date())
          )
        );
      
      if (!resetToken) {
        return res.status(400).json({ error: "Invalid or expired reset link. Please request a new one." });
      }
      
      // Hash the new password
      const hashedPassword = await bcrypt.hash(password, 10);
      
      // Update the user's password
      await storage.updateUser(resetToken.userId, { password: hashedPassword });
      
      // Mark the token as used
      await db
        .update(passwordResetTokens)
        .set({ used: true })
        .where(eq(passwordResetTokens.id, resetToken.id));
      
      res.json({ success: true, message: "Password has been reset successfully. You can now log in with your new password." });
    } catch (error) {
      console.error("Reset password error:", error);
      res.status(500).json({ error: "Failed to reset password" });
    }
  });
  
  // Middleware helper that also checks session-based admin auth
  const requireAdminSession = (req: any, res: any, next: any) => {
    // Check session-based admin auth
    if ((req.session as any)?.isAdmin === true) {
      return next();
    }
    // Fall back to role-based admin auth
    const user = req.user as any;
    if (user?.role === "admin") {
      return next();
    }
    return res.status(403).json({ error: "Admin access required" });
  };

  // Admin endpoints for background check management
  // Get ALL PYCKER applications (pending, approved, rejected)
  app.get("/api/admin/pyckers/all", requireAdminSession, async (req, res) => {
    try {
      const allProfiles = await storage.getAllHaulerProfiles();
      
      const pyckerDetails = await Promise.all(
        allProfiles.map(async (profile) => {
          const user = await storage.getUser(profile.userId);
          let registrationData = {};
          try {
            registrationData = profile.bio ? JSON.parse(profile.bio) : {};
          } catch (e) {}
          return {
            profileId: profile.id,
            userId: profile.userId,
            name: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : '',
            email: user?.email,
            phone: user?.phone,
            companyName: profile.companyName,
            vehicleType: profile.vehicleType,
            backgroundCheckStatus: profile.backgroundCheckStatus,
            canAcceptJobs: profile.canAcceptJobs,
            pyckerTier: profile.pyckerTier,
            registrationData,
            createdAt: (registrationData as any).submittedAt,
          };
        })
      );
      
      res.json(pyckerDetails);
    } catch (error) {
      console.error("Error fetching all pyckers:", error);
      res.status(500).json({ error: "Failed to fetch pyckers" });
    }
  });

  app.get("/api/admin/pyckers/pending", requireAdminSession, async (req, res) => {
    try {
      const allProfiles = await storage.getAllHaulerProfiles();
      const pendingPyckers = allProfiles.filter(p => p.backgroundCheckStatus === "pending");
      
      const pyckerDetails = await Promise.all(
        pendingPyckers.map(async (profile) => {
          const user = await storage.getUser(profile.userId);
          let registrationData = {};
          try {
            registrationData = profile.bio ? JSON.parse(profile.bio) : {};
          } catch (e) {}
          return {
            profileId: profile.id,
            userId: profile.userId,
            name: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : '',
            email: user?.email,
            phone: user?.phone,
            companyName: profile.companyName,
            vehicleType: profile.vehicleType,
            backgroundCheckStatus: profile.backgroundCheckStatus,
            canAcceptJobs: profile.canAcceptJobs,
            registrationData,
            createdAt: (registrationData as any).submittedAt,
          };
        })
      );
      
      res.json(pyckerDetails);
    } catch (error) {
      console.error("Error fetching pending pyckers:", error);
      res.status(500).json({ error: "Failed to fetch pending pyckers" });
    }
  });

  app.post("/api/admin/pyckers/:profileId/approve", requireAdminSession, async (req, res) => {
    try {
      const profile = await storage.updateHaulerProfile(req.params.profileId, {
        backgroundCheckStatus: "approved",
        canAcceptJobs: true,
      });
      
      if (!profile) {
        return res.status(404).json({ error: "Pro profile not found" });
      }
      
      res.json({
        success: true,
        message: "Background check approved. Pro can now accept jobs.",
        profile,
      });
    } catch (error) {
      console.error("Error approving pycker:", error);
      res.status(500).json({ error: "Failed to approve pycker" });
    }
  });

  app.post("/api/admin/pyckers/:profileId/reject", requireAdminSession, async (req, res) => {
    try {
      const { reason } = req.body;
      
      const profile = await storage.updateHaulerProfile(req.params.profileId, {
        backgroundCheckStatus: "rejected",
        canAcceptJobs: false,
      });
      
      if (!profile) {
        return res.status(404).json({ error: "Pro profile not found" });
      }
      
      res.json({
        success: true,
        message: "Background check rejected.",
        reason: reason || "Background check did not pass verification",
        profile,
      });
    } catch (error) {
      console.error("Error rejecting pro:", error);
      res.status(500).json({ error: "Failed to reject pro" });
    }
  });

  // Admin: Get all active jobs for supervision (uses session-based auth)
  app.get("/api/admin/jobs/active", requireAdminSession, async (req, res) => {
    try {
      const jobs = await storage.getAllJobsWithDetails();
      // Filter to only show active jobs (accepted, assigned, in_progress)
      const activeJobs = jobs
        .filter(j => 
          j.status === 'accepted' || 
          j.status === 'assigned' || 
          j.status === 'in_progress'
        )
        .map(job => ({
          ...job,
          // Map customer/hauler info for easier admin UI consumption
          customerName: job.customer ? 
            `${job.customer.firstName || ''} ${job.customer.lastName || ''}`.trim() || 'Customer' : 
            'Unknown Customer',
          customerPhone: job.customer?.phone || job.customerPhone || null,
          haulerName: job.hauler ? 
            `${job.hauler.firstName || ''} ${job.hauler.lastName || ''}`.trim() || 'PYCKER' : 
            (job.haulerProfile?.companyName || 'Unassigned'),
          haulerPhone: job.haulerProfile?.phone || job.hauler?.phone || null,
          livePrice: job.livePrice || job.priceEstimate || 0,
        }));
      res.json(activeJobs);
    } catch (error) {
      console.error("Error getting active jobs for admin:", error);
      res.status(500).json({ error: "Failed to get active jobs" });
    }
  });

  // Admin User Search
  app.get("/api/admin/users/search", requireAdminSession, async (req, res) => {
    try {
      const q = (req.query.q as string || "").toLowerCase();
      if (q.length < 2) return res.json([]);
      const allUsers = await storage.getUsers();
      const results = allUsers.filter((u: any) => {
        const name = `${u.firstName || ""} ${u.lastName || ""}`.toLowerCase();
        const email = (u.email || "").toLowerCase();
        const phone = (u.phone || "").toLowerCase();
        return name.includes(q) || email.includes(q) || phone.includes(q);
      }).slice(0, 20);
      res.json(results);
    } catch (error) {
      console.error("Admin user search error:", error);
      res.status(500).json({ error: "Search failed" });
    }
  });

  // Admin Ban User
  app.post("/api/admin/users/:userId/ban", requireAdminSession, async (req, res) => {
    try {
      const userId = req.params.userId;
      await storage.updateUser(userId, { isBanned: true });
      res.json({ success: true, message: "User banned" });
    } catch (error) {
      console.error("Admin ban user error:", error);
      res.status(500).json({ error: "Failed to ban user" });
    }
  });

  // Admin Refund User (placeholder)
  app.post("/api/admin/users/:userId/refund", requireAdminSession, async (req, res) => {
    try {
      res.json({ success: true, message: "Refund initiated. Check Stripe dashboard for processing." });
    } catch (error) {
      console.error("Admin refund error:", error);
      res.status(500).json({ error: "Failed to process refund" });
    }
  });

  app.get("/api/haulers/filter/:serviceType", async (req, res) => {
    try {
      const haulers = await storage.getAvailableHaulersByServiceType(req.params.serviceType);
      res.json(haulers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch haulers" });
    }
  });

  const insertReviewSchema = z.object({
    haulerId: z.string(),
    customerId: z.string(),
    serviceRequestId: z.string(),
    rating: z.number().min(1).max(5),
    title: z.string().optional(),
    comment: z.string().optional(),
  });

  app.post("/api/reviews", requireAuth, async (req, res) => {
    try {
      const parsed = insertReviewSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request body", details: parsed.error.issues });
      }
      
      const existingReview = await storage.getReviewByServiceRequest(parsed.data.serviceRequestId);
      if (existingReview) {
        return res.status(400).json({ error: "Review already exists for this job" });
      }
      
      const serviceRequest = await storage.getServiceRequest(parsed.data.serviceRequestId);
      if (!serviceRequest || serviceRequest.status !== "completed") {
        return res.status(400).json({ error: "Can only review completed jobs" });
      }
      
      const review = await storage.createReview({
        ...parsed.data,
        createdAt: new Date().toISOString(),
      });

      if (parsed.data.rating === 5 && serviceRequest.assignedHaulerId) {
        await storage.incrementWorkerFiveStarCount(serviceRequest.assignedHaulerId);
      }

      res.status(201).json(review);
    } catch (error) {
      res.status(500).json({ error: "Failed to create review" });
    }
  });

  app.get("/api/service-requests/pending", async (req, res) => {
    try {
      const requests = await storage.getPendingRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch pending requests" });
    }
  });

  app.get("/api/service-requests/:id", requireAuth, async (req: any, res) => {
    try {
      const request = await storage.getServiceRequestWithDetails(req.params.id);
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }
      
      // Get user info to determine role
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      const user = userId ? await storage.getUser(userId) : null;
      const role = (user?.role || 'customer') as 'customer' | 'hauler' | 'admin';
      
      // Use centralized masking helper for consistent contact info protection
      const maskedRequest = maskContactInfoForRole(request as MaskableRequest, role);
      
      res.json(maskedRequest);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch service request" });
    }
  });

  app.post("/api/service-requests", requireAuth, requireCustomer, async (req: any, res) => {
    try {
      // Verify customer has payment method on file
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      
      const user = await storage.getUser(userId);
      if (!user?.stripeCustomerId) {
        return res.status(400).json({ 
          error: "Payment method required",
          code: "PAYMENT_REQUIRED",
          message: "Please add a payment method before booking. You won't be charged until you confirm a booking."
        });
      }
      
      // Verify actual attached payment method via Stripe
      try {
        const paymentMethods = await stripeService.listPaymentMethods(user.stripeCustomerId);
        if (paymentMethods.data.length === 0) {
          return res.status(400).json({ 
            error: "Payment method required",
            code: "PAYMENT_REQUIRED",
            message: "Please add a payment method before booking. You won't be charged until you confirm a booking."
          });
        }
      } catch (error) {
        console.error("Error checking Stripe payment methods:", error);
        // Block booking if payment method verification fails
        return res.status(502).json({ 
          error: "Payment verification failed",
          code: "PAYMENT_VERIFICATION_FAILED",
          message: "Unable to verify your payment method. Please try again or contact support."
        });
      }
      
      const validatedData = insertServiceRequestSchema.parse(req.body);
      
      // Require at least one photo for AI pricing validation
      const photoUrls = validatedData.photoUrls as string[] | undefined;
      if (!photoUrls || photoUrls.length === 0) {
        return res.status(400).json({ 
          error: "At least one photo is required for AI price validation" 
        });
      }
      
      const quote = await storage.calculateQuote({
        serviceType: validatedData.serviceType as any,
        loadSize: validatedData.loadEstimate as any,
        pickupLat: validatedData.pickupLat || undefined,
        pickupLng: validatedData.pickupLng || undefined,
        destinationLat: validatedData.destinationLat || undefined,
        destinationLng: validatedData.destinationLng || undefined,
      });
      
      // Set up 60-second matching timer
      const matchingStartedAt = new Date().toISOString();
      const matchingExpiresAt = new Date(Date.now() + 60 * 1000).toISOString();
      
      const request = await storage.createServiceRequest({
        ...validatedData,
        priceEstimate: quote.totalPrice,
        livePrice: quote.totalPrice,
        surgeFactor: quote.surgeMultiplier,
        status: "matching", // Start in matching status
        matchingStartedAt,
        matchingExpiresAt,
        needsManualMatch: false,
        // Store customer contact info for alerts
        customerPhone: user?.phone || validatedData.customerPhone,
        customerEmail: user?.email || validatedData.customerEmail,
      });
      
      // Use smart matching with language preference
      const matchedHaulers = await storage.getSmartMatchedHaulers({
        serviceType: validatedData.serviceType,
        loadSize: validatedData.loadEstimate,
        pickupLat: validatedData.pickupLat || undefined,
        pickupLng: validatedData.pickupLng || undefined,
        preferVerifiedPro: validatedData.preferVerifiedPro || false,
        preferredLanguage: validatedData.preferredLanguage || undefined,
      });
      
      for (const hauler of matchedHaulers.slice(0, 3)) {
        const haulerQuote = await storage.calculateQuote({
          serviceType: validatedData.serviceType as any,
          loadSize: validatedData.loadEstimate as any,
          pickupLat: validatedData.pickupLat || undefined,
          pickupLng: validatedData.pickupLng || undefined,
          destinationLat: validatedData.destinationLat || undefined,
          destinationLng: validatedData.destinationLng || undefined,
          vehicleType: hauler.profile.vehicleType as any,
        });
        
        await storage.createMatchAttempt({
          requestId: request.id,
          haulerId: hauler.id,
          status: "pending",
          quotedPrice: haulerQuote.totalPrice,
          etaMinutes: Math.floor(Math.random() * 20) + 15,
          expiresAt: new Date(Date.now() + 5 * 60 * 1000).toISOString(),
          createdAt: new Date().toISOString(),
        });
      }
      
      res.status(201).json(request);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      console.error("Error creating service request:", error);
      res.status(500).json({ error: "Failed to create service request" });
    }
  });

  app.patch("/api/service-requests/:id", requireAuth, async (req, res) => {
    try {
      const request = await storage.updateServiceRequest(req.params.id, req.body);
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }
      
      broadcastToJob(req.params.id, {
        type: "request_updated",
        request,
      });
      
      res.json(request);
    } catch (error) {
      res.status(500).json({ error: "Failed to update service request" });
    }
  });

  app.post("/api/service-requests/:id/start", requireAuth, async (req, res) => {
    try {
      const request = await storage.updateServiceRequest(req.params.id, {
        status: "in_progress",
        startedAt: new Date().toISOString(),
      });
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }
      
      broadcastToJob(req.params.id, {
        type: "job_started",
        request,
      });
      
      res.json(request);
    } catch (error) {
      res.status(500).json({ error: "Failed to start job" });
    }
  });

  app.post("/api/service-requests/:id/complete", requireAuth, async (req, res) => {
    try {
      const existingRequest = await storage.getServiceRequest(req.params.id);
      if (!existingRequest) {
        return res.status(404).json({ error: "Service request not found" });
      }

      let paymentResult = null;
      if (existingRequest.stripePaymentIntentId && existingRequest.paymentStatus !== "captured") {
        try {
          let haulerStripeAccountId = null;
          let pyckerTier = 'independent';
          let isVerifiedLlc = false;
          if (existingRequest.assignedHaulerId) {
            const haulerProfile = await storage.getHaulerProfile(existingRequest.assignedHaulerId);
            if (haulerProfile?.stripeAccountId && haulerProfile?.stripeOnboardingComplete) {
              haulerStripeAccountId = haulerProfile.stripeAccountId;
            }
            pyckerTier = haulerProfile?.pyckerTier || 'independent';
            isVerifiedLlc = haulerProfile?.isVerifiedLlc || false;
          }

          const totalAmount = existingRequest.livePrice || req.body.finalPrice || 0;
          paymentResult = await stripeService.capturePaymentAndPayHauler(
            existingRequest.stripePaymentIntentId,
            haulerStripeAccountId,
            totalAmount,
            pyckerTier,
            isVerifiedLlc
          );
        } catch (paymentError) {
          console.error("Payment capture failed:", paymentError);
        }
      }

      const request = await storage.updateServiceRequest(req.params.id, {
        status: "completed",
        completedAt: new Date().toISOString(),
        finalPrice: req.body.finalPrice,
        ...(paymentResult && {
          paymentStatus: "captured",
          platformFee: paymentResult.platformFee,
          haulerPayout: paymentResult.haulerPayout,
          paidAt: new Date().toISOString(),
        }),
      });

      if (existingRequest.customerId) {
        await storage.incrementCustomerJobCount(existingRequest.customerId);
      }

      try {
        await updateHomeScore(existingRequest.customerId, existingRequest.serviceType, req.params.id);
      } catch (scoreErr) {
        console.error("Home score update failed (non-blocking):", scoreErr);
      }
      
      broadcastToJob(req.params.id, {
        type: "job_completed",
        request,
        paymentCaptured: !!paymentResult,
      });
      
      res.json({ ...request, paymentCaptured: !!paymentResult });
    } catch (error) {
      res.status(500).json({ error: "Failed to complete job" });
    }
  });

  // Photo upload for job proof of completion
  app.post("/api/jobs/upload-photos", requireAuth, async (req, res) => {
    try {
      const { jobId } = req.body;
      
      // In production, photos would be uploaded to object storage
      // For now, we'll simulate with placeholder URLs
      const uploadedUrls: string[] = [];
      
      // If files were uploaded via multipart form data, they'd be processed here
      // For demo purposes, return success with placeholder
      const timestamp = Date.now();
      uploadedUrls.push(
        `/api/photos/${jobId}/${timestamp}_before.jpg`,
        `/api/photos/${jobId}/${timestamp}_after.jpg`
      );
      
      res.json({ 
        success: true, 
        urls: uploadedUrls,
        message: "Photos uploaded successfully"
      });
    } catch (error) {
      console.error("Photo upload error:", error);
      res.status(500).json({ error: "Failed to upload photos" });
    }
  });

  // Report issue with a job
  app.post("/api/jobs/:jobId/report-issue", requireAuth, async (req, res) => {
    try {
      const { jobId } = req.params;
      const { type, description } = req.body;
      
      // In production, this would create a support ticket/issue record
      // For now, log it and return success
      console.log(`Issue reported for job ${jobId}:`, { type, description });
      
      // Could store in database, send notification to support team, etc.
      res.json({ 
        success: true, 
        issueId: `ISS-${Date.now()}`,
        jobId,
        type,
        message: "Issue reported successfully. Support will contact you shortly."
      });
    } catch (error) {
      console.error("Report issue error:", error);
      res.status(500).json({ error: "Failed to report issue" });
    }
  });

  app.get("/api/customers/:customerId/requests", requireAuth, requireCustomer, requireOwnership("customerId"), async (req, res) => {
    try {
      const requests = await storage.getServiceRequestsByCustomer(req.params.customerId);
      res.json(requests);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch customer requests" });
    }
  });

  app.get("/api/my-jobs", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });
      const requests = await storage.getServiceRequestsByCustomer(userId);
      res.json(requests);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch jobs" });
    }
  });

  app.get("/api/haulers/:haulerId/jobs", requireAuth, requireHauler, async (req, res) => {
    try {
      const requests = await storage.getServiceRequestsByHauler(req.params.haulerId);
      
      // Use centralized masking helper for consistent contact info protection
      const maskedRequests = requests.map((request: MaskableRequest) => 
        maskContactInfoForRole(request, 'hauler')
      );
      
      res.json(maskedRequests);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch hauler jobs" });
    }
  });

  app.get("/api/haulers/:haulerId/matches", requireAuth, requireHauler, async (req, res) => {
    try {
      const matches = await storage.getPendingMatchesForHauler(req.params.haulerId);
      res.json(matches);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch matches" });
    }
  });

  app.patch("/api/matches/:id", requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const match = await storage.updateMatchAttempt(req.params.id, { status });
      if (!match) {
        return res.status(404).json({ error: "Match not found" });
      }
      
      if (status === "accepted") {
        const request = await storage.getServiceRequest(match.requestId);
        if (request) {
          // Clear matching timer when PYCKER accepts
          await storage.updateServiceRequest(match.requestId, {
            status: "assigned",
            assignedHaulerId: match.haulerId,
            finalPrice: match.quotedPrice,
            acceptedAt: new Date().toISOString(),
            // Clear matching timer fields - job is now matched
            matchingExpiresAt: null,
            needsManualMatch: false,
          });
          
          broadcastToJob(match.requestId, {
            type: "match_accepted",
            match,
          });
        }
      }
      
      res.json(match);
    } catch (error) {
      res.status(500).json({ error: "Failed to update match" });
    }
  });

  app.post("/api/pricing/quote", async (req, res) => {
    try {
      const quoteRequest = quoteRequestSchema.parse(req.body);
      const { userId, bookingSource } = req.body;
      
      // Use the new promotion-aware quote calculation if userId is provided
      if (userId && bookingSource === "app") {
        const quoteWithPromos = await storage.calculateQuoteWithPromotions({
          ...quoteRequest,
          userId,
          bookingSource,
        });
        return res.json(quoteWithPromos);
      }
      
      const quote = await storage.calculateQuote(quoteRequest);
      res.json(quote);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid quote request", details: error.errors });
      }
      res.status(500).json({ error: "Failed to calculate quote" });
    }
  });

  const moveQuoteSchema = z.object({
    pickupZip: z.string().length(5, "Pickup zip code must be 5 digits"),
    destinationZip: z.string().length(5, "Destination zip code must be 5 digits"),
    pickupStairs: z.number().int().min(0).max(20).default(0),
    destinationStairs: z.number().int().min(0).max(20).default(0),
    moveServiceMode: z.enum(["truck_and_mover", "labor_only"]).default("truck_and_mover"),
    basePrice: z.number().min(0).default(99),
  });

  app.post("/api/pricing/move-quote", async (req, res) => {
    try {
      const parseResult = moveQuoteSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ error: "Invalid request", details: parseResult.error.errors });
      }
      const { pickupZip, destinationZip, pickupStairs, destinationStairs, moveServiceMode, basePrice } = parseResult.data;
      
      const pickupSupported = isZipCodeSupported(pickupZip);
      const destSupported = isZipCodeSupported(destinationZip);
      
      if (!pickupSupported || !destSupported) {
        const unsupported = [];
        if (!pickupSupported) unsupported.push(`pickup: ${pickupZip}`);
        if (!destSupported) unsupported.push(`destination: ${destinationZip}`);
        return res.status(400).json({ 
          error: "Zip code not in service area",
          unsupportedZips: unsupported,
          message: "UpTend is currently only available in the Orlando metro area. We're expanding soon!"
        });
      }
      
      const pickupCoords = geocodeZip(pickupZip);
      const destCoords = geocodeZip(destinationZip);
      
      if (!pickupCoords || !destCoords) {
        return res.status(400).json({ error: "Could not locate addresses" });
      }
      
      const distanceMiles = calculateDistance(
        pickupCoords.lat, pickupCoords.lng,
        destCoords.lat, destCoords.lng
      );
      
      const pricing = calculateMovePricing(
        distanceMiles,
        pickupStairs || 0,
        destinationStairs || 0,
        moveServiceMode || 'truck_and_mover',
        basePrice || 99
      );
      
      res.json({
        distanceMiles,
        pickupCoords,
        destinationCoords: destCoords,
        ...pricing
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to calculate move quote" });
    }
  });

  app.get("/api/pricing/supported-zips", async (req, res) => {
    res.json({
      supportedZips: Object.keys(SUPPORTED_ZIP_CODES),
      serviceArea: "Orlando Metro Area"
    });
  });

  // Get distance to nearest dump/transfer station
  app.get("/api/pricing/dump-distance/:zip", async (req, res) => {
    try {
      const { zip } = req.params;
      const coords = geocodeZip(zip);
      
      if (!coords) {
        return res.status(400).json({ 
          error: "Unsupported zip code",
          message: "We currently only service the Orlando metro area."
        });
      }
      
      const dumpInfo = findNearestDump(coords.lat, coords.lng);
      
      res.json({
        zip,
        nearestDump: dumpInfo.name,
        distanceMiles: dumpInfo.distanceMiles,
        estimatedDriveMinutes: dumpInfo.estimatedDriveMinutes,
        distanceFee: dumpInfo.distanceFee,
      });
    } catch (error) {
      console.error("Error calculating dump distance:", error);
      res.status(500).json({ error: "Failed to calculate distance" });
    }
  });

  // Check priority slot availability
  app.get("/api/slots/priority/:date", requireAuth, async (req, res) => {
    try {
      const { date } = req.params;
      const slots = await storage.getAvailablePrioritySlots(date);

      const slotDateObj = new Date(date);
      const dayOfWeek = slotDateObj.getDay();
      const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
      const today = new Date();
      const isSameDay = slotDateObj.toDateString() === today.toDateString();

      res.json({
        date,
        isSameDay,
        isWeekend,
        isPriorityDate: isSameDay || isWeekend,
        message: isSameDay || isWeekend
          ? "Same-day and weekend slots are reserved for app bookings first!"
          : "Regular booking - available on all channels",
        bookedSlots: slots,
      });
    } catch (error) {
      console.error("Error checking priority slots:", error);
      res.status(500).json({ error: "Failed to check priority slots" });
    }
  });

  // Launch notification signup
  app.post("/api/launch-notifications", async (req, res) => {
    try {
      const { email, city } = req.body;
      
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      
      // Save to database
      const { db } = await import("./db");
      const { launchNotifications } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");
      
      // Check if already signed up
      const existing = await db.select().from(launchNotifications).where(eq(launchNotifications.email, email)).limit(1);
      
      if (existing.length > 0) {
        return res.json({ success: true, message: "You're already on the list!" });
      }
      
      // Insert new signup
      await db.insert(launchNotifications).values({ email, city });
      
      // Send confirmation email
      const { sendLaunchNotificationConfirmation, isEmailConfigured } = await import("./services/notifications");
      
      if (isEmailConfigured()) {
        const emailResult = await sendLaunchNotificationConfirmation(email);
        if (!emailResult.success) {
          console.warn("Failed to send launch notification email:", emailResult.error);
        }
      } else {
        console.log("Email not configured - launch notification saved but no confirmation sent");
      }
      
      res.json({ success: true, message: "You're on the list! We'll notify you when we launch." });
    } catch (error: any) {
      console.error("Error saving launch notification:", error);
      // If it's a duplicate email error, treat as success
      if (error.code === '23505') {
        return res.json({ success: true, message: "You're already on the list!" });
      }
      res.status(500).json({ error: "Failed to save notification signup" });
    }
  });

  // Green Guarantee - Approved Facilities endpoints

  // Environmental Certificate endpoints (authentication optional for viewing, required for generation)
  app.get("/api/certificates/:serviceRequestId", requireAuth, async (req, res) => {
    try {
      const { serviceRequestId } = req.params;
      
      // First check if the service request exists
      const serviceRequest = await storage.getServiceRequest(serviceRequestId);
      if (!serviceRequest) {
        return res.status(404).json({ error: "Service request not found" });
      }
      
      // Authorization check: only customer or admin can access (if authenticated)
      const user = req.user as any;
      if (user) {
        if (user.id !== serviceRequest.customerId && user.role !== "admin") {
          return res.status(403).json({ error: "Not authorized to access this certificate", code: "FORBIDDEN" });
        }
      }
      // Note: Allow unauthenticated access for now since tracking page may be shared
      // TODO: Consider requiring auth in production
      
      const certificate = await storage.getEnvironmentalCertificateByServiceRequest(serviceRequestId);
      
      if (!certificate) {
        return res.status(404).json({ error: "Certificate not found for this job", code: "NO_CERTIFICATE" });
      }
      
      res.json(certificate);
    } catch (error) {
      console.error("Error fetching environmental certificate:", error);
      res.status(500).json({ error: "Failed to fetch environmental certificate" });
    }
  });

  app.post("/api/certificates/:serviceRequestId/generate", isAuthenticated, async (req, res) => {
    try {
      const { serviceRequestId } = req.params;
      const user = req.user as any;
      
      if (!user) {
        return res.status(401).json({ error: "Authentication required", code: "UNAUTHORIZED" });
      }
      
      // First check if the service request exists
      const serviceRequest = await storage.getServiceRequest(serviceRequestId);
      if (!serviceRequest) {
        return res.status(404).json({ error: "Service request not found" });
      }
      
      // Authorization check: only customer or admin can generate
      if (user.id !== serviceRequest.customerId && user.role !== "admin") {
        return res.status(403).json({ error: "Not authorized to generate this certificate", code: "FORBIDDEN" });
      }
      
      // Check if job is completed
      if (serviceRequest.status !== "completed") {
        return res.status(400).json({ error: "Cannot generate certificate for incomplete job", code: "JOB_NOT_COMPLETED" });
      }
      
      const certificate = await storage.generateEnvironmentalCertificate(serviceRequestId);
      res.json(certificate);
    } catch (error: any) {
      console.error("Error generating environmental certificate:", error);
      if (error.message === "Service request not found") {
        return res.status(404).json({ error: error.message });
      }
      if (error.message === "Cannot generate certificate for incomplete job") {
        return res.status(400).json({ error: error.message, code: "JOB_NOT_COMPLETED" });
      }
      res.status(500).json({ error: error.message || "Failed to generate environmental certificate" });
    }
  });

  app.get("/api/receipts/green-verified/:serviceRequestId", isAuthenticated, async (req, res) => {
    try {
      const { serviceRequestId } = req.params;
      const serviceRequest = await storage.getServiceRequest(serviceRequestId);
      if (!serviceRequest) {
        return res.status(404).json({ error: "Service request not found" });
      }

      const user = req.user as any;
      if (user && user.id !== serviceRequest.customerId && user.role !== "admin") {
        return res.status(403).json({ error: "Not authorized to view this receipt" });
      }

      const esgLog = await storage.getEsgImpactLogByRequest(serviceRequestId);

      const distanceMiles = (serviceRequest as any).estimatedDistance || esgLog?.haulDistanceMiles || 0;
      const truckSize = (serviceRequest as any).truckSize || 'medium';
      const totalWeightLbs = esgLog?.totalWeightLbs || 0;
      const svcType = serviceRequest.serviceType || 'junk_removal';

      const serviceLabels: Record<string, string> = {
        junk_removal: "Junk Removal",
        furniture_moving: "Furniture Moving",
        garage_cleanout: "Garage Cleanout",
        estate_cleanout: "Estate Cleanout",
        truck_unloading: "Truck Unloading",
        hvac: "HVAC Service",
        cleaning: "Cleaning Service",
      };

      let disposalBreakdown = { recycled: 0, donated: 0, landfilled: 100, eWaste: 0 };
      if (esgLog?.disposalBreakdown) {
        try {
          const parsed = JSON.parse(esgLog.disposalBreakdown);
          disposalBreakdown = { ...disposalBreakdown, ...parsed };
        } catch {}
      }

      const carbonEstimate = estimateCarbonFootprint(
        distanceMiles,
        totalWeightLbs,
        disposalBreakdown,
        truckSize,
        {
          serviceType: svcType,
          metalWeightLbs: esgLog?.metalDivertedLbs || 0,
          seerRatingOld: esgLog?.seerRatingOld || undefined,
          seerRatingNew: esgLog?.seerRatingNew || undefined,
          cleanerType: (esgLog?.cleanerType as any) || undefined,
          waterUsedGallons: esgLog?.waterUsedGallons || undefined,
        }
      );

      let routingSavingsKg = esgLog?.routingSavingsKg || 0;
      let routingSavingsPct = esgLog?.routingSavingsPct || 0;
      if (routingSavingsKg === 0) {
        try {
          const matchingBatches = await db.select().from(dispatchBatches)
            .where(sql`${dispatchBatches.jobIds}::text LIKE ${'%' + serviceRequestId + '%'}`);
          for (const batch of matchingBatches) {
            const jobIds = JSON.parse(batch.jobIds || '[]');
            if (jobIds.includes(serviceRequestId)) {
              routingSavingsKg = (batch.co2SavedLbs || 0) * 0.453592 / Math.max(1, jobIds.length);
              if (batch.totalDistanceMiles && batch.totalDistanceMiles > 0) {
                routingSavingsPct = ((batch.deadheadMilesSaved || 0) / batch.totalDistanceMiles) * 100;
              }
              break;
            }
          }
        } catch {}
      }

      const taxAlerts = carbonEstimate.taxCreditAlerts || getTaxCreditAlerts(svcType, distanceMiles, esgLog?.seerRatingNew || undefined);

      let existingTaxAlerts: any[] = [];
      if (esgLog?.taxCreditAlerts) {
        try { existingTaxAlerts = JSON.parse(esgLog.taxCreditAlerts); } catch {}
      }
      const allTaxAlerts = existingTaxAlerts.length > 0 ? existingTaxAlerts : taxAlerts;

      let serviceDescription = serviceLabels[svcType] || svcType;
      if (svcType === 'furniture_moving' || svcType === 'truck_unloading') {
        const truckLabels: Record<string, string> = { small: '10ft Truck', medium: '16ft Truck', large: '26ft Truck' };
        serviceDescription = `${truckLabels[truckSize] || truckSize} Move (${Math.round(distanceMiles)} miles)`;
      }

      const receipt = {
        serviceRequestId,
        serviceType: svcType,
        serviceDescription,
        status: serviceRequest.status,
        carbonFootprintKg: carbonEstimate.carbonFootprintKg,
        carbonFootprintLbs: carbonEstimate.carbonFootprintLbs,
        proofGreenOptimization: {
          routingSavingsKg: parseFloat(routingSavingsKg.toFixed(2)),
          routingSavingsPct: parseFloat(routingSavingsPct.toFixed(1)),
          description: routingSavingsKg > 0
            ? `AI Routing saved you ${routingSavingsKg.toFixed(0)} kg CO\u2082 (${routingSavingsPct.toFixed(0)}% reduction)`
            : "ProofGreen optimization data will be available after dispatch.",
        },
        breakdown: carbonEstimate.breakdown,
        serviceFactors: carbonEstimate.serviceFactors,
        taxCreditAlerts: allTaxAlerts,
        carbonOffsetCost: carbonEstimate.carbonOffsetCost,
        carbonOffsetPurchased: esgLog?.carbonOffsetPurchased || false,
        treesEquivalent: carbonEstimate.treesEquivalent,
        disposalBreakdown,
        distanceMiles,
        totalWeightLbs,
        diversionRate: esgLog?.diversionRate || 0,
        greenVerified: true,
        issuedAt: esgLog?.createdAt || new Date().toISOString(),
      };

      res.json(receipt);
    } catch (error: any) {
      console.error("Error generating green verified receipt:", error);
      res.status(500).json({ error: "Failed to generate green verified receipt" });
    }
  });

  // ==========================================

  app.get("/api/pricing/rates", async (req, res) => {
    try {
      const rates = await storage.getAllPricingRates();
      res.json(rates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch pricing rates" });
    }
  });

  app.get("/api/pricing/surge", async (req, res) => {
    try {
      const multiplier = await storage.getCurrentSurgeMultiplier();
      const modifiers = await storage.getSurgeModifiers();
      res.json({ currentMultiplier: multiplier, modifiers });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch surge info" });
    }
  });

  app.post("/api/pricing/service-quote", async (req, res) => {
    try {
      const { serviceType, squareFootage, storyCount, laborHours, laborCrewSize } = req.body;
      if (!serviceType) {
        return res.status(400).json({ error: "serviceType is required" });
      }

      const price = calculateServicePrice(serviceType, {
        squareFootage,
        storyCount,
        laborHours,
        laborCrewSize,
      });

      if (price === null) {
        return res.json({
          serviceType,
          label: getServiceLabel(serviceType),
          price: null,
          requiresAiQuote: true,
          message: "This service type requires AI photo analysis for accurate pricing.",
        });
      }

      res.json({
        serviceType,
        label: getServiceLabel(serviceType),
        price,
        priceFormatted: `$${(price / 100).toFixed(2)}`,
        requiresAiQuote: false,
      });
    } catch (error) {
      console.error("Service quote error:", error);
      res.status(500).json({ error: "Failed to calculate price" });
    }
  });

  app.post("/api/service-requests/:id/upsell-check", requireAuth, async (req: any, res) => {
    try {
      const job = await storage.getServiceRequest(req.params.id);
      if (!job) return res.status(404).json({ error: "Job not found" });

      const haulerId = job.assignedHaulerId;
      if (!haulerId) return res.json({ opportunities: [] });

      const haulerProfile = await storage.getHaulerProfile(haulerId);
      if (!haulerProfile) return res.json({ opportunities: [] });

      const opportunities = getUpsellOpportunities(job.serviceType, {
        hasPressureWasher: haulerProfile.hasPressureWasher || false,
        hasTallLadder: haulerProfile.hasTallLadder || false,
        hasDemoTools: haulerProfile.hasDemoTools || false,
        supportedServices: (haulerProfile.supportedServices as string[]) || ["junk_removal"],
      });

      res.json({ opportunities });
    } catch (error) {
      console.error("Upsell check error:", error);
      res.status(500).json({ error: "Failed to check upsell opportunities" });
    }
  });

  app.post("/api/location/update", async (req, res) => {
    try {
      const { userId, jobId, ...locationData } = req.body;
      const location = locationUpdateSchema.parse(locationData);
      
      const savedLocation = await storage.addLocationHistory({
        userId,
        jobId,
        lat: location.lat,
        lng: location.lng,
        accuracy: location.accuracy,
        heading: location.heading,
        speed: location.speed,
        recordedAt: new Date().toISOString(),
      });
      
      if (jobId) {
        broadcastToJob(jobId, {
          type: "location_updated",
          userId,
          ...location,
          timestamp: new Date().toISOString(),
        });
      }
      
      res.json(savedLocation);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid location data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update location" });
    }
  });

  app.get("/api/location/:userId", async (req, res) => {
    try {
      const location = await storage.getLatestLocation(req.params.userId);
      if (!location) {
        return res.status(404).json({ error: "No location found" });
      }
      res.json(location);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch location" });
    }
  });

  app.get("/api/jobs/:jobId/track", async (req, res) => {
    try {
      const request = await storage.getServiceRequestWithDetails(req.params.jobId);
      if (!request) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      let haulerLocation = null;
      let customerLocation = null;
      
      if (request.assignedHaulerId) {
        haulerLocation = await storage.getLatestLocation(request.assignedHaulerId);
      }
      customerLocation = await storage.getLatestLocation(request.customerId);
      
      res.json({
        job: request,
        haulerLocation,
        customerLocation,
        pickup: {
          lat: request.pickupLat,
          lng: request.pickupLng,
          address: request.pickupAddress,
        },
        destination: request.destinationAddress ? {
          lat: request.destinationLat,
          lng: request.destinationLng,
          address: request.destinationAddress,
        } : null,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch tracking info" });
    }
  });

  app.get("/api/jobs/:jobId/history", async (req, res) => {
    try {
      const { userId } = req.query;
      if (!userId || typeof userId !== "string") {
        return res.status(400).json({ error: "userId is required" });
      }
      
      const history = await storage.getLocationHistory(userId, req.params.jobId);
      res.json(history);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch location history" });
    }
  });


  app.get("/api/stripe/publishable-key", async (req, res) => {
    try {
      const key = await stripeService.getPublishableKey();
      res.json({ publishableKey: key });
    } catch (error) {
      console.error("Error getting publishable key:", error);
      res.status(500).json({ error: "Failed to get Stripe publishable key" });
    }
  });

  app.post("/api/payments/create-intent", async (req, res) => {
    try {
      const { jobId, customerId, amount, assignedHaulerId } = req.body;
      
      if (!jobId || !amount) {
        return res.status(400).json({ error: "jobId and amount are required" });
      }

      let user = customerId ? await storage.getUser(customerId) : null;
      
      if (!user) {
        const existingDemo = await storage.getUserByEmail("demo@uptend.app");
        if (existingDemo) {
          user = existingDemo;
        } else {
          user = await storage.createUser({
            role: "customer",
            firstName: "Demo",
            lastName: "Customer",
            email: "demo@uptend.app",
          });
        }
      }

      let stripeCustomerId = user.stripeCustomerId;
      const userName = `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Customer';
      if (!stripeCustomerId) {
        const customer = await stripeService.createCustomer(
          user.email || `customer-${user.id}@uptend.app`,
          userName,
          user.id
        );
        stripeCustomerId = customer.id;
        await storage.updateUser(user.id, { stripeCustomerId: customer.id });
      }

      const paymentIntent = await stripeService.createPaymentIntent(
        amount,
        stripeCustomerId,
        jobId
      );

      const updateData: Record<string, any> = {
        stripePaymentIntentId: paymentIntent.id,
        paymentStatus: "authorized",
        livePrice: amount,
      };
      
      if (assignedHaulerId) {
        updateData.assignedHaulerId = assignedHaulerId;
        updateData.status = "assigned";
      }

      await storage.updateServiceRequest(jobId, updateData);

      res.json({
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
      });
    } catch (error) {
      console.error("Error creating payment intent:", error);
      res.status(500).json({ error: "Failed to create payment intent" });
    }
  });

  app.post("/api/payments/:jobId/capture", async (req, res) => {
    try {
      const { jobId } = req.params;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }

      if (!job.stripePaymentIntentId) {
        return res.status(400).json({ error: "No payment intent for this job" });
      }

      if (job.paymentStatus === "captured") {
        return res.status(400).json({ error: "Payment already captured" });
      }

      let haulerStripeAccountId = null;
      let pyckerTier = 'independent';
      let isVerifiedLlc = false;
      if (job.assignedHaulerId) {
        const haulerProfile = await storage.getHaulerProfile(job.assignedHaulerId);
        if (haulerProfile?.stripeAccountId && haulerProfile?.stripeOnboardingComplete) {
          haulerStripeAccountId = haulerProfile.stripeAccountId;
        }
        pyckerTier = haulerProfile?.pyckerTier || 'independent';
        isVerifiedLlc = haulerProfile?.isVerifiedLlc || false;
      }

      const totalAmount = job.livePrice || 0;
      const result = await stripeService.capturePaymentAndPayHauler(
        job.stripePaymentIntentId,
        haulerStripeAccountId,
        totalAmount,
        pyckerTier,
        isVerifiedLlc
      );

      await storage.updateServiceRequest(jobId, {
        paymentStatus: "captured",
        platformFee: result.platformFee,
        haulerPayout: result.haulerPayout,
        paidAt: new Date().toISOString(),
      });

      res.json({
        success: true,
        platformFee: result.platformFee,
        haulerPayout: result.haulerPayout,
        haulerPaid: !!haulerStripeAccountId,
      });
    } catch (error) {
      console.error("Error capturing payment:", error);
      res.status(500).json({ error: "Failed to capture payment" });
    }
  });

  // BNPL (Buy Now Pay Later) confirmation endpoint
  // This stores the BNPL selection and backup card for orders $250+
  // Note: Full Stripe BNPL integration (Affirm/Klarna) requires merchant-level setup
  // This implementation stores the intent and backup card for tracking
  app.post("/api/payments/confirm-bnpl", requireAuth, async (req, res) => {
    try {
      const { jobId, provider, backupPaymentMethodId } = req.body;
      const userId = (req.user as any).id;
      
      if (!jobId || !provider || !backupPaymentMethodId) {
        return res.status(400).json({ 
          error: "jobId, provider, and backupPaymentMethodId are required" 
        });
      }

      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }

      // Verify the user owns this job or is an admin
      const user = req.user as any;
      if (job.customerId !== userId && user.role !== 'admin') {
        return res.status(403).json({ error: "Not authorized to confirm BNPL for this job" });
      }

      const amount = job.livePrice || job.priceEstimate || 0;
      
      // BNPL only available for orders $250+
      const BNPL_THRESHOLD = 250;
      if (amount < BNPL_THRESHOLD) {
        return res.status(400).json({ 
          error: `BNPL is only available for orders $${BNPL_THRESHOLD} or more` 
        });
      }

      // Valid BNPL providers
      if (!['affirm', 'klarna'].includes(provider)) {
        return res.status(400).json({ error: "Invalid BNPL provider" });
      }

      // Attach the backup payment method to the customer for later use
      const customer = await storage.getUser(job.customerId);
      if (customer?.stripeCustomerId) {
        try {
          await stripeService.attachPaymentMethod(customer.stripeCustomerId, backupPaymentMethodId);
        } catch (attachError) {
          console.log("Payment method may already be attached or invalid:", attachError);
        }
      }

      // Update the service request with BNPL information
      await storage.updateServiceRequest(jobId, {
        bnplEnabled: true,
        bnplProvider: provider,
        bnplPaymentMethodId: backupPaymentMethodId,
        backupPaymentMethodId: backupPaymentMethodId,
        bnplConfirmedAt: new Date().toISOString(),
        paymentStatus: "bnpl_confirmed",
      });

      res.json({
        success: true,
        message: `BNPL payment confirmed with ${provider}`,
        bnplProvider: provider,
        totalAmount: amount,
        installmentAmount: amount / 4,
      });
    } catch (error) {
      console.error("Error confirming BNPL payment:", error);
      res.status(500).json({ error: "Failed to confirm BNPL payment" });
    }
  });

  // Charge BNPL backup card for on-site adjustments (admin/hauler only)
  app.post("/api/payments/:jobId/charge-bnpl-adjustment", requireAuth, async (req, res) => {
    try {
      const { jobId } = req.params;
      const { adjustmentAmount, reason } = req.body;
      const userId = (req.user as any).id;
      const userRole = (req.user as any).role;

      if (!adjustmentAmount || adjustmentAmount <= 0) {
        return res.status(400).json({ error: "Valid adjustment amount is required" });
      }

      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }

      // Only the assigned hauler or admin can charge adjustments
      if (userRole !== 'admin' && job.assignedHaulerId !== userId) {
        return res.status(403).json({ error: "Not authorized to charge adjustments for this job" });
      }

      if (!job.bnplEnabled || !job.backupPaymentMethodId) {
        return res.status(400).json({ 
          error: "This job does not have BNPL with a backup payment method" 
        });
      }

      // Get customer info
      const customer = await storage.getUser(job.customerId);
      if (!customer?.stripeCustomerId) {
        return res.status(400).json({ error: "Customer Stripe account not found" });
      }

      // Create and confirm a payment intent for the adjustment amount
      const adjustmentResult = await stripeService.createAndCaptureAdjustment(
        adjustmentAmount,
        customer.stripeCustomerId,
        job.backupPaymentMethodId,
        jobId
      );

      // Update the job with adjustment info
      await storage.updateServiceRequest(jobId, {
        bnplAdjustmentCharged: (job.bnplAdjustmentCharged || 0) + adjustmentAmount,
        bnplAdjustmentChargedAt: new Date().toISOString(),
      });

      res.json({
        success: true,
        adjustmentAmount,
        reason,
        message: `Successfully charged $${adjustmentAmount.toFixed(2)} to backup card`,
        paymentIntentId: adjustmentResult.paymentIntentId,
      });
    } catch (error) {
      console.error("Error charging BNPL adjustment:", error);
      res.status(500).json({ error: "Failed to charge adjustment to backup card" });
    }
  });

  // ====== JOB MANAGEMENT ENDPOINTS ======

  // PYCKER starts a job (marks as in_progress)
  app.post("/api/jobs/:jobId/start", requireAuth, requireHauler, async (req, res) => {
    try {
      const { jobId } = req.params;
      const userId = (req.user as any).id;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      if (job.assignedHaulerId !== userId) {
        return res.status(403).json({ error: "Not assigned to this job" });
      }
      
      if (job.status !== "accepted" && job.status !== "assigned") {
        return res.status(400).json({ error: "Job cannot be started from current status" });
      }
      
      // Create job completion record to track progress
      const completion = await storage.createJobCompletion({
        serviceRequestId: jobId,
        haulerId: userId,
        arrivedAtPickup: true,
        arrivedAtPickupAt: new Date().toISOString(),
        originalQuote: job.livePrice || 0,
        finalAmount: job.livePrice || 0,
        createdAt: new Date().toISOString(),
      });
      
      // Update job status
      const updated = await storage.updateServiceRequest(jobId, {
        status: "in_progress",
        startedAt: new Date().toISOString(),
      });
      
      // Broadcast update to connected clients
      broadcastToJob(jobId, { type: "job_started", job: updated });
      
      res.json({ success: true, job: updated, completion });
    } catch (error) {
      console.error("Error starting job:", error);
      res.status(500).json({ error: "Failed to start job" });
    }
  });

  // PYCKER adds extra items/adjustments
  app.post("/api/jobs/:jobId/adjustments", requireAuth, requireHauler, async (req, res) => {
    try {
      const { jobId } = req.params;
      const userId = (req.user as any).id;
      const { adjustmentType, itemName, priceChange, reason, photoUrls, quantity } = req.body;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      if (job.assignedHaulerId !== userId) {
        return res.status(403).json({ error: "Not assigned to this job" });
      }
      
      if (job.status !== "in_progress") {
        return res.status(400).json({ error: "Can only add adjustments to in-progress jobs" });
      }
      
      if (!adjustmentType || !itemName || priceChange === undefined) {
        return res.status(400).json({ error: "adjustmentType, itemName, and priceChange are required" });
      }
      
      const adjustment = await storage.createJobAdjustment({
        serviceRequestId: jobId,
        haulerId: userId,
        adjustmentType,
        itemName,
        priceChange,
        reason,
        photoUrls,
        quantity,
        status: "pending",
        createdAt: new Date().toISOString(),
      });
      
      // Broadcast to customer for approval
      broadcastToJob(jobId, { type: "adjustment_added", adjustment });
      
      res.json({ success: true, adjustment });
    } catch (error) {
      console.error("Error adding adjustment:", error);
      res.status(500).json({ error: "Failed to add adjustment" });
    }
  });

  // Get all adjustments for a job
  app.get("/api/jobs/:jobId/adjustments", requireAuth, async (req, res) => {
    try {
      const { jobId } = req.params;
      const adjustments = await storage.getJobAdjustmentsByRequest(jobId);
      res.json(adjustments);
    } catch (error) {
      console.error("Error getting adjustments:", error);
      res.status(500).json({ error: "Failed to get adjustments" });
    }
  });

  // Customer approves/declines an adjustment
  app.patch("/api/jobs/:jobId/adjustments/:adjustmentId", requireAuth, async (req, res) => {
    try {
      const { jobId, adjustmentId } = req.params;
      const { action } = req.body;
      const userId = (req.user as any).id;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      // Customer or admin can approve/decline
      const isCustomer = job.customerId === userId;
      const user = await storage.getUser(userId);
      const isAdmin = user?.role === "admin";
      
      if (!isCustomer && !isAdmin) {
        return res.status(403).json({ error: "Only customer or admin can respond to adjustments" });
      }
      
      let adjustment;
      if (action === "approve") {
        adjustment = await storage.approveJobAdjustment(adjustmentId);
      } else if (action === "decline") {
        adjustment = await storage.declineJobAdjustment(adjustmentId);
      } else {
        return res.status(400).json({ error: "Invalid action. Use 'approve' or 'decline'" });
      }
      
      if (!adjustment) {
        return res.status(404).json({ error: "Adjustment not found" });
      }
      
      // Broadcast to PYCKER
      broadcastToJob(jobId, { type: "adjustment_updated", adjustment });
      
      res.json({ success: true, adjustment });
    } catch (error) {
      console.error("Error updating adjustment:", error);
      res.status(500).json({ error: "Failed to update adjustment" });
    }
  });

  // PYCKER updates job completion checklist
  app.patch("/api/jobs/:jobId/completion", requireAuth, requireHauler, async (req, res) => {
    try {
      const { jobId } = req.params;
      const userId = (req.user as any).id;
      const updates = req.body;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      if (job.assignedHaulerId !== userId) {
        return res.status(403).json({ error: "Not assigned to this job" });
      }
      
      let completion = await storage.getJobCompletion(jobId);
      if (!completion) {
        completion = await storage.createJobCompletion({
          serviceRequestId: jobId,
          haulerId: userId,
          originalQuote: job.livePrice || 0,
          finalAmount: job.livePrice || 0,
          createdAt: new Date().toISOString(),
        });
      }
      
      const updated = await storage.updateJobCompletion(completion.id, updates);
      
      res.json({ success: true, completion: updated });
    } catch (error) {
      console.error("Error updating completion:", error);
      res.status(500).json({ error: "Failed to update completion" });
    }
  });

  // Get job completion status
  app.get("/api/jobs/:jobId/completion", requireAuth, async (req, res) => {
    try {
      const { jobId } = req.params;
      const completion = await storage.getJobCompletion(jobId);
      res.json(completion || null);
    } catch (error) {
      console.error("Error getting completion:", error);
      res.status(500).json({ error: "Failed to get completion" });
    }
  });

  // PYCKER marks job as complete and triggers payment capture
  app.post("/api/jobs/:jobId/complete", requireAuth, requireHauler, async (req, res) => {
    try {
      const { jobId } = req.params;
      const userId = (req.user as any).id;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      if (job.assignedHaulerId !== userId) {
        return res.status(403).json({ error: "Not assigned to this job" });
      }
      
      if (job.status !== "in_progress") {
        return res.status(400).json({ error: "Job must be in progress to complete" });
      }
      
      // Check completion checklist
      const completion = await storage.getJobCompletion(jobId);
      if (!completion) {
        return res.status(400).json({ error: "Job completion record not found. Start the job first." });
      }
      
      if (!completion.workCompleted) {
        return res.status(400).json({ error: "Please verify work is completed before finishing" });
      }
      
      // Calculate final amount including approved adjustments
      const adjustments = await storage.getJobAdjustmentsByRequest(jobId);
      const approvedAdjustments = adjustments.filter(a => a.status === "approved");
      const pendingAdjustments = adjustments.filter(a => a.status === "pending");
      
      // Warn if there are pending adjustments
      if (pendingAdjustments.length > 0) {
        return res.status(400).json({ 
          error: "There are pending adjustments waiting for customer approval",
          pendingCount: pendingAdjustments.length
        });
      }
      
      const baseAmount = job.livePrice || 0;
      const adjustmentsTotal = approvedAdjustments.reduce((sum, a) => sum + (a.priceChange || 0), 0);
      const finalAmount = baseAmount + adjustmentsTotal;
      
      // Update completion record
      await storage.updateJobCompletion(completion.id, {
        workCompleted: true,
        workCompletedAt: new Date().toISOString(),
        finalAmount,
        adjustmentsTotal,
      });
      
      // Update service request
      const updated = await storage.updateServiceRequest(jobId, {
        status: "completed",
        livePrice: finalAmount,
      });
      
      try {
        await updateHomeScore(job.customerId, job.serviceType, jobId);
      } catch (scoreErr) {
        console.error("Home score update failed (non-blocking):", scoreErr);
      }

      // Attempt to capture payment
      if (job.stripePaymentIntentId) {
        try {
          let haulerStripeAccountId = null;
          let pyckerTier = 'independent';
          let isVerifiedLlc = false;
          if (job.assignedHaulerId) {
            const haulerProfile = await storage.getHaulerProfile(job.assignedHaulerId);
            if (haulerProfile?.stripeAccountId && haulerProfile?.stripeOnboardingComplete) {
              haulerStripeAccountId = haulerProfile.stripeAccountId;
            }
            pyckerTier = haulerProfile?.pyckerTier || 'independent';
            isVerifiedLlc = haulerProfile?.isVerifiedLlc || false;
          }
          
          const result = await stripeService.capturePaymentAndPayHauler(
            job.stripePaymentIntentId,
            haulerStripeAccountId,
            finalAmount,
            pyckerTier,
            isVerifiedLlc
          );
          
          await storage.updateServiceRequest(jobId, {
            paymentStatus: "captured",
            platformFee: result.platformFee,
            haulerPayout: result.haulerPayout,
            paidAt: new Date().toISOString(),
          });
          
          // Broadcast completion
          broadcastToJob(jobId, { 
            type: "job_completed", 
            job: updated,
            paymentCaptured: true,
            finalAmount,
          });
          
          res.json({ 
            success: true, 
            job: updated,
            paymentCaptured: true,
            finalAmount,
            platformFee: result.platformFee,
            haulerPayout: result.haulerPayout,
          });
        } catch (paymentError) {
          console.error("Payment capture failed:", paymentError);
          res.json({ 
            success: true, 
            job: updated,
            paymentCaptured: false,
            paymentError: "Payment capture failed - manual follow-up required",
            finalAmount,
          });
        }
      } else {
        broadcastToJob(jobId, { type: "job_completed", job: updated, finalAmount });
        res.json({ success: true, job: updated, paymentCaptured: false, finalAmount });
      }
    } catch (error) {
      console.error("Error completing job:", error);
      res.status(500).json({ error: "Failed to complete job" });
    }
  });

  // Admin: Get all active jobs with details
  app.get("/api/admin/jobs", requireAuth, requireAdmin, async (req, res) => {
    try {
      const jobs = await storage.getAllJobsWithDetails();
      res.json(jobs);
    } catch (error) {
      console.error("Error getting admin jobs:", error);
      res.status(500).json({ error: "Failed to get jobs" });
    }
  });

  // Admin: Force approve/decline an adjustment
  app.patch("/api/admin/jobs/:jobId/adjustments/:adjustmentId", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { adjustmentId } = req.params;
      const { action, notes } = req.body;
      
      let adjustment;
      if (action === "approve") {
        adjustment = await storage.approveJobAdjustment(adjustmentId);
        if (adjustment && notes) {
          // Store admin notes in reason field with prefix
          const currentReason = adjustment.reason || '';
          await storage.updateJobAdjustment(adjustmentId, { 
            reason: currentReason ? `${currentReason} | Admin: ${notes}` : `Admin: ${notes}` 
          });
        }
      } else if (action === "decline") {
        adjustment = await storage.declineJobAdjustment(adjustmentId);
        if (adjustment && notes) {
          const currentReason = adjustment.reason || '';
          await storage.updateJobAdjustment(adjustmentId, { 
            reason: currentReason ? `${currentReason} | Admin: ${notes}` : `Admin: ${notes}` 
          });
        }
      } else {
        return res.status(400).json({ error: "Invalid action" });
      }
      
      res.json({ success: true, adjustment });
    } catch (error) {
      console.error("Error updating adjustment as admin:", error);
      res.status(500).json({ error: "Failed to update adjustment" });
    }
  });

  // ====== END JOB MANAGEMENT ENDPOINTS ======

  app.post("/api/haulers/:profileId/stripe-onboard", requireAuth, requireHauler, async (req, res) => {
    try {
      const { profileId } = req.params;
      
      const profile = await storage.getHaulerProfileById(profileId);
      if (!profile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      const user = await storage.getUser(profile.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      let accountId = profile.stripeAccountId;
      const userName = `${user.firstName || ''} ${user.lastName || ''}`.trim();
      if (!accountId) {
        const account = await stripeService.createConnectAccount(
          profileId,
          user.email || `pro-${user.id}@uptend.app`,
          profile.companyName || userName || 'Pro'
        );
        accountId = account.id;
        await storage.updateHaulerProfile(profileId, { stripeAccountId: accountId });
      }

      const baseUrl = `https://${process.env.REPLIT_DOMAINS?.split(',')[0] || 'localhost:5000'}`;
      const accountLink = await stripeService.createAccountLink(
        accountId,
        `${baseUrl}/hauler-dashboard?stripe=success`,
        `${baseUrl}/hauler-dashboard?stripe=refresh`
      );

      res.json({ url: accountLink.url });
    } catch (error) {
      console.error("Error creating Stripe onboarding:", error);
      res.status(500).json({ error: "Failed to start Stripe onboarding" });
    }
  });

  app.get("/api/haulers/:profileId/stripe-status", requireAuth, requireHauler, async (req, res) => {
    try {
      const { profileId } = req.params;
      
      const profile = await storage.getHaulerProfileById(profileId);
      if (!profile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      if (!profile.stripeAccountId) {
        return res.json({
          hasAccount: false,
          onboardingComplete: false,
        });
      }

      const status = await stripeService.getAccountStatus(profile.stripeAccountId);
      
      if (status.chargesEnabled && status.payoutsEnabled && !profile.stripeOnboardingComplete) {
        await storage.updateHaulerProfile(profileId, { stripeOnboardingComplete: true });
      }

      res.json({
        hasAccount: true,
        onboardingComplete: status.chargesEnabled && status.payoutsEnabled,
        chargesEnabled: status.chargesEnabled,
        payoutsEnabled: status.payoutsEnabled,
        detailsSubmitted: status.detailsSubmitted,
      });
    } catch (error) {
      console.error("Error getting Stripe status:", error);
      res.status(500).json({ error: "Failed to get Stripe account status" });
    }
  });

  app.get("/api/payments/:jobId/breakdown", async (req, res) => {
    try {
      const { jobId } = req.params;
      
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }

      // Get the assigned hauler's tier for proper fee calculation
      let pyckerTier = 'independent';
      if (job.assignedHaulerId) {
        const haulerProfile = await storage.getHaulerProfile(job.assignedHaulerId);
        pyckerTier = haulerProfile?.pyckerTier || 'independent';
      }

      const totalAmount = job.livePrice || 0;
      const platformFeePercent = stripeService.getPlatformFeePercent(pyckerTier);
      const haulerPayoutPercent = stripeService.getHaulerPayoutPercent(pyckerTier);
      const platformFee = stripeService.calculatePlatformFee(totalAmount, pyckerTier);
      const haulerPayout = stripeService.calculateHaulerPayout(totalAmount, pyckerTier);

      res.json({
        totalAmount,
        platformFee,
        haulerPayout,
        platformFeePercent,
        haulerPayoutPercent,
        pyckerTier,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to calculate payment breakdown" });
    }
  });

  app.post("/api/haulers/:profileId/setup-card", requireAuth, requireHauler, async (req, res) => {
    try {
      const { profileId } = req.params;
      
      const profile = await storage.getHaulerProfileById(profileId);
      if (!profile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      const user = await storage.getUser(profile.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      let incidentCustomerId = profile.incidentStripeCustomerId;
      const userName = `${user.firstName || ''} ${user.lastName || ''}`.trim();
      if (!incidentCustomerId) {
        const customer = await stripeService.createIncidentCustomer(
          profileId,
          user.email || `pro-${user.id}@uptend.app`,
          profile.companyName || userName || 'Pro'
        );
        incidentCustomerId = customer.id;
        await storage.updateHaulerProfile(profileId, { incidentStripeCustomerId: incidentCustomerId });
      }

      const setupIntent = await stripeService.createSetupIntent(incidentCustomerId);

      res.json({
        clientSecret: setupIntent.client_secret,
        customerId: incidentCustomerId,
      });
    } catch (error) {
      console.error("Error creating setup intent:", error);
      res.status(500).json({ error: "Failed to set up card" });
    }
  });

  app.post("/api/haulers/:profileId/confirm-card", requireAuth, requireHauler, async (req, res) => {
    try {
      const { profileId } = req.params;
      const { paymentMethodId } = req.body;
      
      const profile = await storage.getHaulerProfileById(profileId);
      if (!profile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      if (!profile.incidentStripeCustomerId) {
        return res.status(400).json({ error: "No Stripe customer set up" });
      }

      await stripeService.attachPaymentMethod(profile.incidentStripeCustomerId, paymentMethodId);
      
      const canAcceptJobs = profile.backgroundCheckStatus === "clear" && true;
      
      await storage.updateHaulerProfile(profileId, {
        incidentPaymentMethodId: paymentMethodId,
        hasCardOnFile: true,
        canAcceptJobs,
      });

      res.json({ success: true, canAcceptJobs });
    } catch (error) {
      console.error("Error confirming card:", error);
      res.status(500).json({ error: "Failed to confirm card" });
    }
  });

  app.get("/api/haulers/:profileId/compliance", requireAuth, requireHauler, async (req, res) => {
    try {
      const { profileId } = req.params;
      
      const profile = await storage.getHaulerProfileById(profileId);
      if (!profile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      const penalties = await storage.getPenaltiesByHauler(profile.userId);
      const unpaidPenalties = penalties.filter(p => p.status === "assessed");

      // Check if NDA is accepted
      const ndaAccepted = !!profile.ndaAcceptedAt;
      
      // canAcceptJobs requires: card on file, background check clear, AND NDA signed
      const canAcceptJobs = profile.hasCardOnFile && 
                           profile.backgroundCheckStatus === "clear" && 
                           ndaAccepted &&
                           unpaidPenalties.length === 0;

      res.json({
        hasCardOnFile: profile.hasCardOnFile,
        backgroundCheckStatus: profile.backgroundCheckStatus,
        stripeOnboardingComplete: profile.stripeOnboardingComplete,
        canAcceptJobs,
        unpaidPenaltiesCount: unpaidPenalties.length,
        unpaidPenaltiesAmount: unpaidPenalties.reduce((sum, p) => sum + (p.amount || 0), 0),
        ndaAccepted,
        ndaAcceptedAt: profile.ndaAcceptedAt,
        ndaVersion: profile.ndaVersion,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch compliance status" });
    }
  });

  app.post("/api/haulers/:profileId/request-background-check", requireAuth, requireHauler, async (req, res) => {
    try {
      const { profileId } = req.params;
      
      const profile = await storage.getHaulerProfileById(profileId);
      if (!profile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      const canAcceptJobs = profile.hasCardOnFile && true;

      await storage.updateHaulerProfile(profileId, {
        backgroundCheckStatus: "clear",
        backgroundCheckCompletedAt: new Date().toISOString(),
        canAcceptJobs,
      });

      res.json({ 
        status: "clear", 
        message: "Background check passed (demo mode)",
        canAcceptJobs,
      });
    } catch (error) {
      console.error("Error requesting background check:", error);
      res.status(500).json({ error: "Failed to request background check" });
    }
  });

  app.post("/api/service-requests/:id/accept", requireAuth, requireHauler, async (req, res) => {
    try {
      const { id } = req.params;
      const user = req.user as any;
      const haulerId = req.body.haulerId || user.id;

      if (user.role !== "admin" && req.body.haulerId && req.body.haulerId !== user.id) {
        return res.status(403).json({ 
          error: "Cannot accept jobs for another worker",
          reason: "You can only accept jobs for yourself."
        });
      }

      const request = await storage.getServiceRequest(id);
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }

      if (request.acceptedAt) {
        return res.status(409).json({ 
          error: "Job no longer available",
          reason: "This job has already been accepted by another PYCKER."
        });
      }

      if (request.status !== "pending" && request.status !== "requested" && request.status !== "matched") {
        return res.status(409).json({ 
          error: "Job no longer available",
          reason: `This job is no longer accepting workers (status: ${request.status}).`
        });
      }

      if (request.cancelledAt) {
        return res.status(409).json({ 
          error: "Job no longer available",
          reason: "This job has been cancelled."
        });
      }

      const haulerProfile = await storage.getHaulerProfile(haulerId);
      if (!haulerProfile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      if (!haulerProfile.hasCardOnFile) {
        return res.status(403).json({ 
          error: "Cannot accept jobs",
          reason: "Card on file required - add a payment method first"
        });
      }

      if (haulerProfile.backgroundCheckStatus !== "clear") {
        return res.status(403).json({ 
          error: "Cannot accept jobs",
          reason: "Background check required - complete background verification first"
        });
      }

      const penalties = await storage.getPenaltiesByHauler(haulerId);
      const unpaidPenalties = penalties.filter(p => p.status === "assessed");
      if (unpaidPenalties.length > 0) {
        return res.status(403).json({ 
          error: "Cannot accept jobs",
          reason: `Outstanding penalties must be resolved first ($${unpaidPenalties.reduce((sum, p) => sum + (p.amount || 0), 0)})`
        });
      }

      const now = new Date();
      const contactRequiredBy = new Date(now.getTime() + 5 * 60 * 1000);
      
      const updated = await storage.acceptServiceRequest(id, haulerId, {
        status: "assigned",
        assignedHaulerId: haulerId,
        acceptedAt: now.toISOString(),
        contactRequiredBy: contactRequiredBy.toISOString(),
        contactReleasedAt: now.toISOString(),
      });

      if (!updated) {
        return res.status(409).json({ 
          error: "Job no longer available",
          reason: "This job was just taken by another PYCKER."
        });
      }

      broadcastToJob(id, {
        type: "job_accepted",
        haulerId,
        acceptedAt: now,
      });

      res.json(updated);
    } catch (error) {
      console.error("Error accepting job:", error);
      res.status(500).json({ error: "Failed to accept job" });
    }
  });

  // PYCKER confirms they called the customer
  app.post("/api/service-requests/:id/confirm-call", async (req, res) => {
    try {
      const { id } = req.params;
      const { haulerId } = req.body;

      const request = await storage.getServiceRequest(id);
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }

      if (request.assignedHaulerId !== haulerId) {
        return res.status(403).json({ error: "Only the assigned PYCKER can confirm the call" });
      }

      if (request.contactConfirmedAt) {
        return res.json({ 
          success: true, 
          message: "Call already confirmed",
          contactConfirmedAt: request.contactConfirmedAt 
        });
      }

      const now = new Date().toISOString();
      const updated = await storage.updateServiceRequest(id, {
        contactConfirmedAt: now,
      });

      broadcastToJob(id, {
        type: "call_confirmed",
        haulerId,
        contactConfirmedAt: now,
      });

      res.json({ 
        success: true, 
        message: "Call confirmed",
        contactConfirmedAt: now 
      });
    } catch (error) {
      console.error("Error confirming call:", error);
      res.status(500).json({ error: "Failed to confirm call" });
    }
  });

  // PYCKER cancels a job after accepting - automatic $25 penalty
  app.post("/api/service-requests/:id/cancel", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { haulerId, reason } = req.body;

      // Validate required fields
      if (!haulerId) {
        return res.status(400).json({ error: "haulerId is required" });
      }

      const request = await storage.getServiceRequest(id);
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }

      if (request.assignedHaulerId !== haulerId) {
        return res.status(403).json({ error: "Only the assigned PYCKER can cancel this job" });
      }

      // Only allow cancellation of jobs that were actually accepted
      const validStatusesForCancellation = ["assigned", "in_progress"];
      if (!validStatusesForCancellation.includes(request.status)) {
        return res.status(400).json({ 
          error: "Cannot cancel this job",
          reason: `Job is in '${request.status}' status - only assigned or in-progress jobs can be cancelled`
        });
      }

      // Verify the job was actually accepted
      if (!request.acceptedAt) {
        return res.status(400).json({ 
          error: "Cannot cancel this job",
          reason: "Job was never formally accepted"
        });
      }

      if (request.status === "completed") {
        return res.status(400).json({ error: "Cannot cancel a completed job" });
      }

      if (request.cancelledAt) {
        return res.status(400).json({ error: "Job already cancelled" });
      }

      const haulerProfile = await storage.getHaulerProfile(haulerId);
      if (!haulerProfile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      // Verify card on file before allowing cancellation
      if (!haulerProfile.incidentStripeCustomerId || !haulerProfile.incidentPaymentMethodId) {
        return res.status(400).json({ 
          error: "Cannot cancel job - no payment method on file for penalty",
          reason: "A $25 cancellation penalty will be charged"
        });
      }

      const now = new Date().toISOString();
      let penaltyId: string | null = null;
      let penaltyCharged = false;

      // Create $25 penalty for cancellation after acceptance
      const penalty = await storage.createHaulerPenalty({
        haulerId,
        requestId: id,
        reason: `Job cancellation after acceptance: ${reason || "No reason provided"}`,
        amount: 25,
        status: "assessed",
        createdAt: now,
      });
      penaltyId = penalty.id;

      // Attempt to charge the penalty if card on file exists
      if (haulerProfile.incidentStripeCustomerId && haulerProfile.incidentPaymentMethodId) {
        try {
          const paymentIntent = await stripeService.chargeIncidentPenalty(
            haulerProfile.incidentStripeCustomerId,
            haulerProfile.incidentPaymentMethodId,
            25,
            `UpTend cancellation penalty: ${reason || "Job cancelled after acceptance"}`,
            { penaltyId: penalty.id, haulerId, requestId: id }
          );

          await storage.updateHaulerPenalty(penalty.id, {
            status: "charged",
            stripePaymentIntentId: paymentIntent.id,
            chargedAt: now,
          });
          penaltyCharged = true;
        } catch (chargeError) {
          console.error("Failed to charge cancellation penalty:", chargeError);
          // Penalty remains assessed but not charged - will need manual collection
        }
      }

      // Update the service request with cancellation details
      const updated = await storage.updateServiceRequest(id, {
        status: "cancelled",
        cancelledAt: now,
        cancelledBy: "pycker",
        cancellationReason: reason || "No reason provided",
        cancellationPenaltyCharged: penaltyCharged,
        cancellationPenaltyId: penaltyId,
        haulerPenaltyApplied: true,
      });

      // Broadcast cancellation to customer
      broadcastToJob(id, {
        type: "job_cancelled",
        cancelledBy: "pycker",
        reason: reason || "PYCKER cancelled the job",
        cancelledAt: now,
      });

      res.json({
        success: true,
        message: penaltyCharged 
          ? "Job cancelled - $25 penalty charged to your card on file" 
          : "Job cancelled - $25 penalty assessed (pending collection)",
        penaltyCharged,
        penaltyId,
        penaltyAmount: 25,
        request: updated,
      });
    } catch (error) {
      console.error("Error cancelling job:", error);
      res.status(500).json({ error: "Failed to cancel job" });
    }
  });

  app.post("/api/penalties/:haulerId/assess", async (req, res) => {
    try {
      const { haulerId } = req.params;
      const { requestId, reason, amount = 25 } = req.body;

      const haulerProfile = await storage.getHaulerProfile(haulerId);
      if (!haulerProfile) {
        return res.status(404).json({ error: "Hauler profile not found" });
      }

      const penalty = await storage.createHaulerPenalty({
        haulerId,
        requestId,
        reason: reason || "Job not completed after acceptance",
        amount,
        status: "assessed",
        createdAt: new Date().toISOString(),
      });

      if (requestId) {
        await storage.updateServiceRequest(requestId, {
          haulerPenaltyApplied: true,
        });
      }

      if (haulerProfile.incidentStripeCustomerId && haulerProfile.incidentPaymentMethodId) {
        try {
          const paymentIntent = await stripeService.chargeIncidentPenalty(
            haulerProfile.incidentStripeCustomerId,
            haulerProfile.incidentPaymentMethodId,
            amount,
            `honkIQ penalty: ${reason || "Job not completed"}`,
            { penaltyId: penalty.id, haulerId, requestId: requestId || "" }
          );

          await storage.updateHaulerPenalty(penalty.id, {
            status: "charged",
            stripePaymentIntentId: paymentIntent.id,
            chargedAt: new Date().toISOString(),
          });

          res.json({ 
            penalty: { ...penalty, status: "charged" }, 
            charged: true,
            paymentIntentId: paymentIntent.id,
          });
        } catch (chargeError) {
          console.error("Failed to charge penalty:", chargeError);
          res.json({ penalty, charged: false, chargeError: "Payment failed" });
        }
      } else {
        res.json({ penalty, charged: false, reason: "No payment method on file" });
      }
    } catch (error) {
      console.error("Error assessing penalty:", error);
      res.status(500).json({ error: "Failed to assess penalty" });
    }
  });

  app.get("/api/penalties/:haulerId", async (req, res) => {
    try {
      const { haulerId } = req.params;
      const penalties = await storage.getPenaltiesByHauler(haulerId);
      res.json(penalties);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch penalties" });
    }
  });

  app.get("/api/service-requests/:id/contact", async (req, res) => {
    try {
      const { id } = req.params;
      const { haulerId } = req.query;

      const request = await storage.getServiceRequestWithDetails(id);
      if (!request) {
        return res.status(404).json({ error: "Service request not found" });
      }

      const customerName = request.customer ? `${request.customer.firstName || ''} ${request.customer.lastName || ''}`.trim() : '';
      if (request.assignedHaulerId !== haulerId || !request.acceptedAt) {
        return res.json({
          contactMasked: true,
          customerName: customerName.split(" ")[0] + " ***",
          customerPhone: "***-***-****",
          customerEmail: "***@***.***",
        });
      }

      res.json({
        contactMasked: false,
        customerName,
        customerPhone: request.customer?.phone,
        customerEmail: request.customer?.email,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch contact info" });
    }
  });

  app.post("/api/jobs/:jobId/tip", async (req, res) => {
    try {
      const { jobId } = req.params;
      const { tipAmount, customerId } = req.body;

      if (!tipAmount || tipAmount <= 0) {
        return res.status(400).json({ error: "Invalid tip amount" });
      }

      const request = await storage.getServiceRequestWithDetails(jobId);
      if (!request) {
        return res.status(404).json({ error: "Job not found" });
      }

      if (request.status !== "completed") {
        return res.status(400).json({ error: "Can only tip after job is completed" });
      }

      const customer = await storage.getUser(customerId);
      if (!customer?.stripeCustomerId) {
        return res.status(400).json({ error: "Customer payment info not found" });
      }

      const haulrProfile = await storage.getHaulerProfile(request.assignedHaulerId!);
      if (!haulrProfile?.stripeAccountId) {
        return res.status(400).json({ error: "IQ Pro payment account not found" });
      }

      const tipPaymentIntent = await stripeService.createTipPaymentIntent(
        tipAmount,
        customer.stripeCustomerId,
        jobId
      );

      res.json({
        clientSecret: tipPaymentIntent.client_secret,
        tipAmount,
        message: "Tip goes 100% to your IQ Pro",
      });
    } catch (error) {
      console.error("Error creating tip:", error);
      res.status(500).json({ error: "Failed to process tip" });
    }
  });

  app.post("/api/jobs/:jobId/tip/confirm", async (req, res) => {
    try {
      const { jobId } = req.params;
      const { paymentIntentId, tipAmount } = req.body;

      const request = await storage.getServiceRequestWithDetails(jobId);
      if (!request) {
        return res.status(404).json({ error: "Job not found" });
      }

      const haulrProfile = await storage.getHaulerProfile(request.assignedHaulerId!);
      if (!haulrProfile?.stripeAccountId) {
        return res.status(400).json({ error: "IQ Pro payment account not found" });
      }

      const transfer = await stripeService.transferTipToPycker(
        paymentIntentId,
        haulrProfile.stripeAccountId,
        tipAmount,
        jobId
      );

      await storage.updateServiceRequest(jobId, {
        tipAmount,
        tipPaidAt: new Date().toISOString(),
        tipStripeTransferId: transfer.id,
      });

      res.json({
        success: true,
        transferId: transfer.id,
        tipAmount,
        message: "Tip sent directly to your IQ Pro!",
      });
    } catch (error) {
      console.error("Error confirming tip:", error);
      res.status(500).json({ error: "Failed to confirm tip" });
    }
  });

  // Referral endpoints
  app.post("/api/referrals", async (req, res) => {
    try {
      const { referrerId, referredEmail } = req.body;
      
      if (!referrerId || !referredEmail) {
        return res.status(400).json({ error: "Referrer ID and email are required" });
      }

      if (!referredEmail.includes("@")) {
        return res.status(400).json({ error: "Invalid email format" });
      }

      const existingReferrals = await storage.getReferralsByReferrer(referrerId);
      const duplicate = existingReferrals.find(r => r.referredEmail.toLowerCase() === referredEmail.toLowerCase());
      if (duplicate) {
        return res.status(400).json({ error: "You've already referred this email address" });
      }

      const referralCode = `HONKIQ${Math.random().toString(36).substring(2, 8).toUpperCase()}`;
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 30);

      const referral = await storage.createReferral({
        referrerId,
        referredEmail: referredEmail.toLowerCase(),
        referralCode,
        status: "pending",
        referrerBonusAmount: 50,
        referredBonusAmount: 50,
        createdAt: new Date().toISOString(),
        expiresAt: expiresAt.toISOString(),
      });

      res.json(referral);
    } catch (error) {
      console.error("Error creating referral:", error);
      res.status(500).json({ error: "Failed to create referral" });
    }
  });

  app.get("/api/referrals/code/:code", async (req, res) => {
    try {
      const { code } = req.params;
      const referral = await storage.getReferralByCode(code);
      
      if (!referral) {
        return res.status(404).json({ error: "Referral code not found" });
      }

      res.json(referral);
    } catch (error) {
      console.error("Error fetching referral:", error);
      res.status(500).json({ error: "Failed to fetch referral" });
    }
  });

  app.get("/api/referrals/:referrerId", async (req, res) => {
    try {
      const { referrerId } = req.params;
      const referrals = await storage.getReferralsByReferrer(referrerId);
      
      const stats = {
        total: referrals.length,
        pending: referrals.filter(r => r.status === "pending").length,
        completed: referrals.filter(r => r.status === "completed" || r.status === "paid").length,
        totalEarned: referrals
          .filter(r => r.status === "paid")
          .reduce((sum, r) => sum + (r.referrerBonusAmount || 0), 0),
      };

      res.json({ referrals, stats });
    } catch (error) {
      console.error("Error fetching referrals:", error);
      res.status(500).json({ error: "Failed to fetch referrals" });
    }
  });

  app.patch("/api/referrals/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const referral = await storage.updateReferral(id, updates);
      if (!referral) {
        return res.status(404).json({ error: "Referral not found" });
      }

      res.json(referral);
    } catch (error) {
      console.error("Error updating referral:", error);
      res.status(500).json({ error: "Failed to update referral" });
    }
  });

  app.post("/api/ai/analyze-photos", async (req, res) => {
    try {
      const { photoUrls } = req.body;
      
      if (!photoUrls || !Array.isArray(photoUrls) || photoUrls.length === 0) {
        return res.status(400).json({ error: "Photo URLs are required" });
      }

      const analysis = await analyzePhotos(photoUrls);
      res.json(analysis);
    } catch (error) {
      console.error("Error analyzing photos:", error);
      res.status(500).json({ error: "Failed to analyze photos" });
    }
  });

  app.post("/api/ai/quick-estimate", async (req, res) => {
    try {
      const { description } = req.body;
      
      if (!description) {
        return res.status(400).json({ error: "Description is required" });
      }

      const estimate = await getQuickEstimate(description);
      res.json(estimate);
    } catch (error) {
      console.error("Error getting quick estimate:", error);
      res.status(500).json({ error: "Failed to get estimate" });
    }
  });

  app.post("/api/ai/analyze-load", async (req, res) => {
    try {
      const contentType = req.headers["content-type"] || "";
      let serviceType = "junk_removal";
      let imageCount = 1;

      if (contentType.includes("multipart/form-data")) {
        const rawBody = await new Promise<string>((resolve) => {
          let data = "";
          req.on("data", (chunk: Buffer) => {
            data += chunk.toString();
          });
          req.on("end", () => resolve(data));
        });
        
        const serviceMatch = rawBody.match(/name="serviceType"\r?\n\r?\n([^\r\n]+)/);
        if (serviceMatch) {
          serviceType = serviceMatch[1];
        }
        imageCount = (rawBody.match(/name="image\d+"/g) || []).length || 1;
      } else {
        serviceType = req.body?.serviceType || "junk_removal";
        imageCount = req.body?.imageCount || 1;
      }

      const basePrices: Record<string, { low: number; high: number; items: string[] }> = {
        junk_removal: { low: 99, high: 249, items: ["Furniture", "Appliances", "General debris"] },
        furniture_moving: { low: 89, high: 199, items: ["Couch/Sofa", "Bed frame", "Tables/Chairs"] },
        garage_cleanout: { low: 179, high: 449, items: ["Tools", "Storage items", "Old equipment", "General clutter"] },
        truck_unloading: { low: 150, high: 350, items: ["Full truck contents", "Furniture", "Boxes"] },
      };

      const base = basePrices[serviceType] || basePrices.junk_removal;
      const sizeMultiplier = 1 + (imageCount - 1) * 0.15;
      
      res.json({
        lowPrice: Math.round(base.low * sizeMultiplier),
        highPrice: Math.round(base.high * sizeMultiplier),
        identifiedItems: base.items,
        confidence: 0.85,
        message: "AI analysis complete",
      });
    } catch (error) {
      console.error("Error analyzing load:", error);
      res.status(500).json({ error: "Failed to analyze load" });
    }
  });

  app.post("/api/matching/smart", async (req, res) => {
    try {
      const { serviceType, loadSize, pickupLat, pickupLng, isPriority, preferVerifiedPro } = req.body;
      
      if (!serviceType || !loadSize) {
        return res.status(400).json({ error: "Service type and load size are required" });
      }

      const haulers = await storage.getSmartMatchedHaulers({
        serviceType,
        loadSize,
        pickupLat,
        pickupLng,
        isPriority,
        preferVerifiedPro,
      });

      res.json({ haulers, isPriority: !!isPriority });
    } catch (error) {
      console.error("Error getting smart matches:", error);
      res.status(500).json({ error: "Failed to get matches" });
    }
  });

  app.post("/api/business-accounts", requireAuth, async (req, res) => {
    try {
      const businessAccountValidation = z.object({
        userId: z.string(),
        businessName: z.string(),
        businessType: z.string(),
        taxId: z.string().optional(),
        billingAddress: z.string().optional(),
        billingCity: z.string().optional(),
        billingState: z.string().optional(),
        billingZip: z.string().optional(),
        primaryContactName: z.string().optional(),
        primaryContactPhone: z.string().optional(),
        primaryContactEmail: z.string().optional(),
        volumeDiscountTier: z.string().optional(),
        monthlyJobTarget: z.number().optional(),
        invoicingEnabled: z.boolean().optional(),
        netPaymentTerms: z.number().optional(),
      });

      const parseResult = businessAccountValidation.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          error: "Invalid data", 
          details: parseResult.error.flatten().fieldErrors 
        });
      }

      const accountData = parseResult.data;
      
      if (!accountData.userId || !accountData.businessName || !accountData.businessType) {
        return res.status(400).json({ error: "User ID, business name, and type are required" });
      }

      const existing = await storage.getBusinessAccountByUser(accountData.userId);
      if (existing) {
        return res.status(400).json({ error: "Business account already exists for this user" });
      }

      const account = await storage.createBusinessAccount({
        ...accountData,
        createdAt: new Date().toISOString(),
      });

      res.status(201).json(account);
    } catch (error) {
      console.error("Error creating business account:", error);
      res.status(500).json({ error: "Failed to create business account" });
    }
  });

  app.get("/api/business-accounts/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const account = await storage.getBusinessAccountByUser(userId);
      
      if (!account) {
        return res.status(404).json({ error: "Business account not found" });
      }

      const recurringJobs = await storage.getRecurringJobsByBusinessAccount(account.id);
      res.json({ account, recurringJobs });
    } catch (error) {
      console.error("Error fetching business account:", error);
      res.status(500).json({ error: "Failed to fetch business account" });
    }
  });

  app.patch("/api/business-accounts/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const account = await storage.updateBusinessAccount(id, updates);
      if (!account) {
        return res.status(404).json({ error: "Business account not found" });
      }

      res.json(account);
    } catch (error) {
      console.error("Error updating business account:", error);
      res.status(500).json({ error: "Failed to update business account" });
    }
  });

  app.post("/api/recurring-jobs", requireAuth, async (req, res) => {
    try {
      const recurringJobValidation = z.object({
        businessAccountId: z.string(),
        serviceType: z.string(),
        pickupAddress: z.string(),
        pickupCity: z.string().optional(),
        pickupZip: z.string().optional(),
        description: z.string().optional(),
        frequency: z.string().optional(),
        preferredDayOfWeek: z.number().optional(),
        preferredTimeSlot: z.string().optional(),
        estimatedLoadSize: z.string().optional(),
        negotiatedPrice: z.number().optional(),
        isActive: z.boolean().optional(),
      });

      const parseResult = recurringJobValidation.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          error: "Invalid data", 
          details: parseResult.error.flatten().fieldErrors 
        });
      }

      const jobData = parseResult.data;
      
      if (!jobData.businessAccountId || !jobData.serviceType || !jobData.pickupAddress) {
        return res.status(400).json({ error: "Business account, service type, and address are required" });
      }

      const job = await storage.createRecurringJob({
        ...jobData,
        pickupCity: jobData.pickupCity || "",
        pickupZip: jobData.pickupZip || "",
        frequency: jobData.frequency || "weekly",
        estimatedLoadSize: jobData.estimatedLoadSize || "medium",
        createdAt: new Date().toISOString(),
      });

      res.status(201).json(job);
    } catch (error) {
      console.error("Error creating recurring job:", error);
      res.status(500).json({ error: "Failed to create recurring job" });
    }
  });

  app.get("/api/recurring-jobs/:businessAccountId", requireAuth, async (req, res) => {
    try {
      const { businessAccountId } = req.params;
      const jobs = await storage.getRecurringJobsByBusinessAccount(businessAccountId);
      res.json(jobs);
    } catch (error) {
      console.error("Error fetching recurring jobs:", error);
      res.status(500).json({ error: "Failed to fetch recurring jobs" });
    }
  });

  app.patch("/api/recurring-jobs/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const job = await storage.updateRecurringJob(id, updates);
      if (!job) {
        return res.status(404).json({ error: "Recurring job not found" });
      }

      res.json(job);
    } catch (error) {
      console.error("Error updating recurring job:", error);
      res.status(500).json({ error: "Failed to update recurring job" });
    }
  });

  app.get("/api/loyalty/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      let account = await storage.getLoyaltyAccount(userId);
      
      if (!account) {
        account = await storage.createLoyaltyAccount({
          userId,
          currentPoints: 0,
          lifetimePoints: 0,
          currentTier: "bronze",
          createdAt: new Date().toISOString(),
        });
      }

      const transactions = await storage.getLoyaltyTransactions(userId);
      const rewards = await storage.getLoyaltyRewards();

      res.json({ account, transactions, availableRewards: rewards });
    } catch (error) {
      console.error("Error fetching loyalty account:", error);
      res.status(500).json({ error: "Failed to fetch loyalty account" });
    }
  });

  app.post("/api/loyalty/:userId/earn", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const { amount, serviceRequestId } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ error: "Valid amount is required" });
      }

      const pointsToEarn = Math.floor(amount * POINTS_PER_DOLLAR);
      const transaction = await storage.addLoyaltyPoints(
        userId, 
        pointsToEarn, 
        `Earned ${pointsToEarn} points for $${amount} job`,
        serviceRequestId
      );

      const account = await storage.getLoyaltyAccount(userId);
      res.json({ transaction, account });
    } catch (error) {
      console.error("Error earning points:", error);
      res.status(500).json({ error: "Failed to earn points" });
    }
  });

  app.post("/api/loyalty/:userId/redeem", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const { rewardId } = req.body;
      
      if (!rewardId) {
        return res.status(400).json({ error: "Reward ID is required" });
      }

      const reward = await storage.getLoyaltyReward(rewardId);
      if (!reward) {
        return res.status(404).json({ error: "Reward not found" });
      }

      if (!reward.isActive) {
        return res.status(400).json({ error: "This reward is no longer available" });
      }

      if (reward.usageLimit && (reward.currentUsageCount || 0) >= reward.usageLimit) {
        return res.status(400).json({ error: "This reward has reached its usage limit" });
      }

      const now = new Date().toISOString();
      if (reward.validFrom && now < reward.validFrom) {
        return res.status(400).json({ error: "This reward is not yet available" });
      }
      if (reward.validUntil && now > reward.validUntil) {
        return res.status(400).json({ error: "This reward has expired" });
      }

      const account = await storage.getLoyaltyAccount(userId);
      if (!account) {
        return res.status(404).json({ error: "Loyalty account not found" });
      }

      const tierOrder = ["bronze", "silver", "gold", "platinum"];
      const userTierIndex = tierOrder.indexOf(account.currentTier || "bronze");
      const requiredTierIndex = tierOrder.indexOf(reward.minimumTier || "bronze");
      if (userTierIndex < requiredTierIndex) {
        return res.status(400).json({ error: `This reward requires ${reward.minimumTier} tier or higher` });
      }

      if ((account.currentPoints || 0) < reward.pointsCost) {
        return res.status(400).json({ error: "Insufficient points" });
      }

      const transaction = await storage.redeemLoyaltyPoints(
        userId,
        reward.pointsCost,
        `Redeemed: ${reward.name}`
      );

      if (!transaction) {
        return res.status(400).json({ error: "Failed to redeem points" });
      }

      const updatedAccount = await storage.getLoyaltyAccount(userId);
      res.json({ 
        success: true, 
        reward,
        transaction, 
        account: updatedAccount,
        appliedDiscount: reward.discountAmount || (reward.discountPercent ? `${reward.discountPercent}%` : null)
      });
    } catch (error) {
      console.error("Error redeeming reward:", error);
      res.status(500).json({ error: "Failed to redeem reward" });
    }
  });

  app.get("/api/loyalty/rewards", requireAuth, async (req, res) => {
    try {
      const rewards = await storage.getLoyaltyRewards();
      res.json(rewards);
    } catch (error) {
      console.error("Error fetching rewards:", error);
      res.status(500).json({ error: "Failed to fetch rewards" });
    }
  });

  // === PYCKER Price Verification ===
  app.post("/api/jobs/:jobId/verify-price", async (req, res) => {
    try {
      const { jobId } = req.params;
      const { finalPrice, notes, verifiedItems } = req.body;

      if (typeof finalPrice !== "number" || finalPrice <= 0) {
        return res.status(400).json({ error: "Valid finalPrice is required" });
      }

      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }

      const updateData: Record<string, unknown> = {
        finalPrice,
        verificationStatus: "verified",
        verifiedAt: new Date().toISOString(),
        verifierNotes: notes || null,
      };

      if (verifiedItems && Array.isArray(verifiedItems)) {
        updateData.verifiedItems = JSON.stringify(verifiedItems);
      }

      await storage.updateServiceRequest(jobId, updateData);

      res.json({ success: true, finalPrice, verificationStatus: "verified" });
    } catch (error) {
      console.error("Error verifying price:", error);
      res.status(500).json({ error: "Failed to verify price" });
    }
  });

  app.get("/api/jobs/:jobId/price-range", async (req, res) => {
    try {
      const { jobId } = req.params;
      const job = await storage.getServiceRequest(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }

      res.json({
        aiPriceMin: job.aiPriceMin,
        aiPriceMax: job.aiPriceMax,
        aiConfidence: job.aiConfidence,
        priceEstimate: job.priceEstimate,
        finalPrice: job.finalPrice,
        verificationStatus: job.verificationStatus,
        verifiedAt: job.verifiedAt,
        verifierNotes: job.verifierNotes,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch price range" });
    }
  });

  // === Admin Surge Pricing Controls ===
  app.get("/api/admin/surge-modifiers", async (req, res) => {
    try {
      const modifiers = await storage.getSurgeModifiers();
      const currentMultiplier = await storage.getCurrentSurgeMultiplier();
      res.json({ modifiers, currentMultiplier });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch surge modifiers" });
    }
  });

  app.post("/api/admin/surge-modifiers", async (req, res) => {
    try {
      const { dayOfWeek, startHour, endHour, multiplier, reason, isActive } = req.body;

      if (typeof startHour !== "number" || typeof endHour !== "number" || typeof multiplier !== "number") {
        return res.status(400).json({ error: "startHour, endHour, and multiplier are required numbers" });
      }
      if (multiplier < 0.5 || multiplier > 5.0) {
        return res.status(400).json({ error: "Multiplier must be between 0.5 and 5.0" });
      }
      if (startHour < 0 || startHour > 23 || endHour < 0 || endHour > 23) {
        return res.status(400).json({ error: "Hours must be between 0 and 23" });
      }

      const modifier = await storage.createSurgeModifier({
        dayOfWeek: dayOfWeek ?? null,
        startHour,
        endHour,
        multiplier,
        reason: reason || null,
        isActive: isActive ?? true,
      });
      res.json(modifier);
    } catch (error) {
      res.status(500).json({ error: "Failed to create surge modifier" });
    }
  });

  app.patch("/api/admin/surge-modifiers/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const updated = await storage.updateSurgeModifier(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update surge modifier" });
    }
  });

  app.delete("/api/admin/surge-modifiers/:id", async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteSurgeModifier(id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete surge modifier" });
    }
  });

  // === Multi-Stop Route Optimization ===
  app.get("/api/haulers/:haulerId/optimized-route", async (req, res) => {
    try {
      const { haulerId } = req.params;
      const jobs = await storage.getHaulerActiveJobs(haulerId);

      if (jobs.length <= 1) {
        return res.json({ jobs, optimized: false, message: "Only one job, no optimization needed" });
      }

      const optimized = optimizeRoute(jobs);
      
      for (let i = 0; i < optimized.length; i++) {
        await storage.updateServiceRequest(optimized[i].id, { routeOrder: i + 1 });
      }

      res.json({ jobs: optimized, optimized: true, totalJobs: optimized.length });
    } catch (error) {
      console.error("Route optimization error:", error);
      res.status(500).json({ error: "Failed to optimize route" });
    }
  });

  // === Booking Chatbot ===
  app.post("/api/chatbot/message", async (req, res) => {
    try {
      const { message, context } = req.body;
      if (!message || typeof message !== "string") {
        return res.status(400).json({ error: "message is required" });
      }

      const openai = new OpenAI({
        apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY,
        baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL,
      });

      const systemPrompt = `You are the UpTend booking assistant. UpTend is Orlando's first AI-powered home services and material recovery platform.

KEY FACTS:
- Service area: Orange County, Seminole County, Osceola County (Central Florida)
- Hours: 7 AM - 10 PM, 7 days a week
- Services: Junk Removal, Furniture Moving, Garage Cleanout, Estate Cleanout, U-Haul/Truck Unloading
- PYCKERs are verified contractors matched to you in 60 seconds

PRICING (Junk Removal):
- Minimum Load (1-2 items): $99
- Quarter Load (3-5 items): $139
- Half Load (6-10 items): $229
- 3/4 Load (11-15 items): $329
- Full Load (truckload): $429
- Stairs: Flat $25 fee
- Moving: $1/mile + base rate

BUNDLE DISCOUNTS:
- 3-5 items: 10% off
- 6-10 items: 15% off
- 11+ items: 20% off

KEY DIFFERENTIATORS:
- AI-powered instant quotes from photos
- 60-second PYCKER matching
- Real-time GPS tracking
- Green Verified disposal with environmental certificates
- No lead fees, no callbacks, no bidding wars
- Prices are AI estimates confirmed by your PYCKER on arrival

IMPORTANT: All prices are AI-generated estimates shown as a range. The assigned PYCKER verifies items on-site and confirms the final price before work begins.

Be helpful, concise, and friendly. Help customers understand services, get rough estimates, and guide them to book through the app. If they describe items, give them a rough price range. Always encourage them to upload photos for the most accurate AI quote.`;

      const messages: any[] = [
        { role: "system", content: systemPrompt },
      ];

      if (context?.history && Array.isArray(context.history)) {
        for (const msg of context.history.slice(-10)) {
          messages.push({ role: msg.role, content: msg.content });
        }
      }

      messages.push({ role: "user", content: message });

      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages,
        max_tokens: 500,
        temperature: 0.7,
      });

      const reply = response.choices[0]?.message?.content || "I'm sorry, I couldn't process that. Please try again.";

      res.json({ reply, role: "assistant" });
    } catch (error) {
      console.error("Chatbot error:", error);
      res.status(500).json({ error: "Failed to process message" });
    }
  });

  // ==========================================
  // AI Resale Listing Generator
  // ==========================================
  app.post("/api/ai/generate-listing", requireAuth, async (req, res) => {
    try {
      const { photoUrl } = req.body;

      if (!photoUrl) {
        return res.status(400).json({ message: "No photo provided" });
      }

      const openai = new OpenAI({
        apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY,
        baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL,
      });

      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: `You are an expert reseller on Facebook Marketplace. 
            Analyze the image provided. Identify the main item.
            Generate a JSON response with:
            - title: A catchy, SEO-friendly title (max 50 chars).
            - price: A realistic used price estimate (integer).
            - description: A persuasive description highlighting condition and features (max 300 chars).
            - tags: A list of 5 hashtags.`
          },
          {
            role: "user",
            content: [
              { type: "text", text: "Create a sales listing for this item." },
              { type: "image_url", image_url: { url: photoUrl } },
            ],
          },
        ],
        response_format: { type: "json_object" },
      });

      const listingData = JSON.parse(response.choices[0]?.message?.content || "{}");
      res.json(listingData);

    } catch (error) {
      console.error("AI Resale Listing Error:", error);
      res.status(500).json({ message: "Failed to generate listing" });
    }
  });

  // ==========================================
  // Hauler Manifest Scanner (Chain of Custody)
  // ==========================================
  const manifestUpload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 50 * 1024 * 1024 } });

  app.post("/api/hauler/scan-manifest", requireAuth, manifestUpload.single("video"), async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No video uploaded" });
      }

      const jobId = req.body.jobId;

      // MVP: Smart mock AI analysis of loaded items
      // Production: Extract frames -> GPT-4o Vision -> item detection with condition assessment
      await new Promise(r => setTimeout(r, 1500));

      const mockInventories = [
        [
          { name: "Beige Sofa", condition: "Fair", resale_potential: true },
          { name: "Coffee Table", condition: "Good", resale_potential: true },
          { name: "Floor Lamp", condition: "Poor", resale_potential: false },
        ],
        [
          { name: "Queen Mattress", condition: "Fair", resale_potential: false },
          { name: "Wooden Bookshelf", condition: "Good", resale_potential: true },
          { name: "Office Chair", condition: "Good", resale_potential: true },
          { name: "Desk", condition: "Fair", resale_potential: true },
        ],
        [
          { name: "Treadmill", condition: "Good", resale_potential: true },
          { name: "Tool Bench", condition: "Fair", resale_potential: true },
          { name: "Old Refrigerator", condition: "Poor", resale_potential: false },
        ],
      ];

      const inventory = mockInventories[Math.floor(Math.random() * mockInventories.length)];

      res.json({
        success: true,
        itemCount: inventory.length,
        inventory,
        jobId,
        message: "Evidence Secured",
      });
    } catch (error) {
      console.error("Manifest Scan Error:", error);
      res.status(500).json({ message: "Scan failed" });
    }
  });

  // ==========================================
  // Hauler Earnings API
  // ==========================================
  app.get("/api/hauler/earnings", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Authentication required" });
      }

      // MVP: Return aggregated earnings from completed service requests
      // In production, this would pull from a dedicated payouts table
      const completedJobs = await db.select()
        .from(serviceRequests)
        .where(
          and(
            eq(serviceRequests.haulerId, userId),
            eq(serviceRequests.status, "completed")
          )
        )
        .orderBy(desc(serviceRequests.updatedAt))
        .limit(50);

      const now = new Date();
      const weekStart = new Date(now);
      weekStart.setDate(weekStart.getDate() - weekStart.getDay());
      weekStart.setHours(0, 0, 0, 0);

      let total = 0;
      let weekly = 0;
      const history = completedJobs.map(job => {
        // Default to 75% payout rate (Rookie tier)
        const jobPrice = job.priceEstimate || job.livePrice || 0;
        const priceCents = Math.round(jobPrice * 100);
        const payoutCents = Math.round(priceCents * 0.75);
        
        total += payoutCents;
        
        const jobDate = job.updatedAt || job.createdAt;
        if (jobDate && new Date(jobDate) >= weekStart) {
          weekly += payoutCents;
        }

        return {
          id: job.id,
          serviceType: job.serviceType,
          address: job.pickupAddress || "Service Location",
          date: (jobDate || new Date()).toISOString(),
          amount: payoutCents,
          status: "paid",
        };
      });

      res.json({ total, weekly, history });
    } catch (error) {
      console.error("Earnings Error:", error);
      res.status(500).json({ message: "Failed to load earnings" });
    }
  });

  // ==========================================
  // AI Room Scanner / Video Inventory Analysis
  // ==========================================
  const videoUpload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 50 * 1024 * 1024 } });

  app.post("/api/ai/analyze-room", requireAuth, videoUpload.single("video"), async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No video uploaded" });
      }

      // For the MVP, we use a smart mock that simulates AI analysis.
      // In production, you'd extract key frames from the video, upload them to
      // cloud storage, then send frame URLs to GPT-4o for spatial analysis.
      await new Promise(r => setTimeout(r, 2000));

      const roomTypes = [
        {
          estimated_volume_cu_ft: 450,
          truck_load_estimate: "1/4 Truck",
          inventory: [
            { item: "Samsung TV 65-inch", category: "Electronics", value_est: 300 },
            { item: "Leather Sectional Sofa", category: "Furniture", value_est: 150 },
            { item: "Oak Coffee Table", category: "Furniture", value_est: 50 },
            { item: "Floor Lamp", category: "Decor", value_est: 25 },
            { item: "Misc. Cardboard Boxes (x5)", category: "Junk", value_est: 0 },
          ],
          summary: "Living room cleanout. Mostly furniture and electronics. One heavy item (Sofa).",
        },
        {
          estimated_volume_cu_ft: 280,
          truck_load_estimate: "1/8 Truck",
          inventory: [
            { item: "Queen Bed Frame (Wood)", category: "Furniture", value_est: 80 },
            { item: "Nightstand (pair)", category: "Furniture", value_est: 40 },
            { item: "Dresser 6-Drawer", category: "Furniture", value_est: 120 },
            { item: "Desk Chair (Office)", category: "Furniture", value_est: 35 },
          ],
          summary: "Bedroom cleanout. Mostly medium-weight furniture. No hazardous items.",
        },
        {
          estimated_volume_cu_ft: 650,
          truck_load_estimate: "1/2 Truck",
          inventory: [
            { item: "Treadmill", category: "Gym", value_est: 200 },
            { item: "Tool Bench + Tools", category: "Tools", value_est: 150 },
            { item: "Old Refrigerator", category: "Appliance", value_est: 0 },
            { item: "Outdoor Patio Set", category: "Outdoor", value_est: 75 },
            { item: "Misc. Storage Tubs (x8)", category: "Junk", value_est: 0 },
            { item: "Bicycle", category: "Outdoor", value_est: 60 },
          ],
          summary: "Garage cleanout. Mix of gym equipment, tools, and bulky items. Refrigerator requires special disposal.",
        },
      ];

      const selected = roomTypes[Math.floor(Math.random() * roomTypes.length)];

      res.json({ success: true, data: selected });
    } catch (error) {
      console.error("Room Analysis Error:", error);
      res.status(500).json({ message: "Analysis Failed" });
    }
  });

  // ==========================================
  // AI Safety Co-Pilot - Hazard Detection
  // ==========================================
  app.post("/api/ai/safety-check", requireAuth, async (req, res) => {
    try {
      const { photoUrls, serviceType, serviceRequestId, haulerId } = req.body;
      if (!photoUrls || !Array.isArray(photoUrls) || photoUrls.length === 0) {
        return res.status(400).json({ error: "Photo URLs required" });
      }

      const result = await analyzePhotosForHazards(photoUrls, serviceType || "junk_removal");

      if (result.alerts.length > 0 && serviceRequestId && haulerId) {
        for (const alert of result.alerts) {
          await storage.createSafetyAlert({
            serviceRequestId,
            haulerId,
            alertType: alert.alertType,
            severity: alert.severity,
            description: alert.description,
            safetyInstructions: alert.safetyInstructions,
            disposalGuideUrl: alert.disposalGuideUrl || null,
            photoUrl: photoUrls[0] || null,
            createdAt: new Date().toISOString(),
          });
        }
      }

      res.json(result);
    } catch (error) {
      console.error("Safety check error:", error);
      res.status(500).json({ error: "Safety analysis failed" });
    }
  });

  app.get("/api/jobs/:jobId/safety-alerts", requireAuth, async (req, res) => {
    try {
      const alerts = await storage.getSafetyAlertsByRequest(req.params.jobId);
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to get safety alerts" });
    }
  });

  app.post("/api/safety-alerts/:alertId/acknowledge", requireAuth, async (req, res) => {
    try {
      const alert = await storage.acknowledgeSafetyAlert(req.params.alertId);
      if (!alert) return res.status(404).json({ error: "Alert not found" });
      res.json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to acknowledge alert" });
    }
  });

  // ==========================================
  // Predictive Job Bundling - AI Suggestions
  // ==========================================
  app.post("/api/ai/bundling-suggestions", async (req, res) => {
    try {
      const { identifiedItems, serviceType, photoUrls, serviceRequestId, customerId } = req.body;
      if (!identifiedItems || !Array.isArray(identifiedItems) || identifiedItems.length === 0) {
        return res.json({ suggestions: [] });
      }

      const suggestions = await generateBundlingSuggestions(identifiedItems, serviceType || "junk_removal", photoUrls);

      if (suggestions.length > 0 && serviceRequestId && customerId) {
        for (const suggestion of suggestions) {
          await storage.createBundlingSuggestion({
            serviceRequestId,
            customerId,
            suggestedServiceType: suggestion.suggestedServiceType,
            suggestedItems: JSON.stringify(suggestion.suggestedItems),
            reason: suggestion.reason,
            estimatedAdditionalCost: suggestion.estimatedAdditionalCost,
            discountPercent: suggestion.discountPercent,
            createdAt: new Date().toISOString(),
          });
        }
      }

      res.json({ suggestions });
    } catch (error) {
      console.error("Bundling suggestions error:", error);
      res.status(500).json({ error: "Failed to generate bundling suggestions" });
    }
  });

  app.get("/api/jobs/:jobId/bundling-suggestions", async (req, res) => {
    try {
      const suggestions = await storage.getBundlingSuggestionsByRequest(req.params.jobId);
      res.json(suggestions);
    } catch (error) {
      res.status(500).json({ error: "Failed to get bundling suggestions" });
    }
  });

  app.post("/api/bundling-suggestions/:id/accept", requireAuth, async (req, res) => {
    try {
      const suggestion = await storage.updateBundlingSuggestion(req.params.id, {
        accepted: true,
        acceptedAt: new Date().toISOString(),
      });
      if (!suggestion) return res.status(404).json({ error: "Suggestion not found" });
      res.json(suggestion);
    } catch (error) {
      res.status(500).json({ error: "Failed to accept suggestion" });
    }
  });

  app.post("/api/bundling-suggestions/:id/dismiss", requireAuth, async (req, res) => {
    try {
      const suggestion = await storage.updateBundlingSuggestion(req.params.id, {
        dismissed: true,
        dismissedAt: new Date().toISOString(),
      });
      if (!suggestion) return res.status(404).json({ error: "Suggestion not found" });
      res.json(suggestion);
    } catch (error) {
      res.status(500).json({ error: "Failed to dismiss suggestion" });
    }
  });

  // ==========================================
  // ESG Impact Tracking & Carbon Estimation
  // ==========================================
  app.post("/api/esg/track-impact", requireAuth, async (req, res) => {
    try {
      const { serviceRequestId, haulerId, customerId, items, distanceMiles, totalWeightLbs, disposalBreakdown } = req.body;
      if (!serviceRequestId) return res.status(400).json({ error: "Service request ID required" });

      const categorization = items && items.length > 0
        ? await categorizeItemsForDisposal(items)
        : null;

      const breakdown = disposalBreakdown || {
        recycled: categorization?.totals?.diversion_rate ? categorization.totals.diversion_rate * 100 : 30,
        donated: 20,
        landfilled: 40,
        eWaste: 10,
      };

      const carbon = estimateCarbonFootprint(
        distanceMiles || 10,
        totalWeightLbs || categorization?.totals?.total_weight_lbs || 200,
        breakdown
      );

      const log = await storage.createEsgImpactLog({
        serviceRequestId,
        haulerId: haulerId || null,
        customerId: customerId || null,
        carbonFootprintLbs: carbon.carbonFootprintLbs,
        carbonOffsetCost: carbon.carbonOffsetCost,
        haulDistanceMiles: distanceMiles || 10,
        totalWeightLbs: totalWeightLbs || categorization?.totals?.total_weight_lbs || 200,
        disposalBreakdown: JSON.stringify(breakdown),
        aiCategorization: categorization ? JSON.stringify(categorization) : null,
        recycledWeightLbs: categorization?.totals?.recycled_lbs || 0,
        donatedWeightLbs: categorization?.totals?.donated_lbs || 0,
        landfilledWeightLbs: categorization?.totals?.landfilled_lbs || 0,
        eWasteWeightLbs: categorization?.totals?.e_waste_lbs || 0,
        diversionRate: categorization?.totals?.diversion_rate || breakdown.recycled / 100 + breakdown.donated / 100,
        treesEquivalent: categorization?.environmental_impact?.trees_equivalent || carbon.carbonFootprintLbs / 48,
        waterSavedGallons: categorization?.environmental_impact?.water_saved_gallons || 0,
        energySavedKwh: categorization?.environmental_impact?.energy_saved_kwh || 0,
        createdAt: new Date().toISOString(),
      });

      res.json({ log, carbon, categorization });
    } catch (error) {
      console.error("ESG tracking error:", error);
      res.status(500).json({ error: "Failed to track ESG impact" });
    }
  });

  app.get("/api/esg/summary", async (req, res) => {
    try {
      const summary = await storage.getEsgSummary();
      res.json(summary);
    } catch (error) {
      res.status(500).json({ error: "Failed to get ESG summary" });
    }
  });

  app.get("/api/esg/impact/:serviceRequestId", async (req, res) => {
    try {
      const log = await storage.getEsgImpactLogByRequest(req.params.serviceRequestId);
      if (!log) return res.status(404).json({ error: "ESG impact log not found" });
      res.json(log);
    } catch (error) {
      res.status(500).json({ error: "Failed to get ESG impact" });
    }
  });

  app.get("/api/esg/customer/:customerId", requireAuth, async (req, res) => {
    try {
      const logs = await storage.getEsgImpactLogsByCustomer(req.params.customerId);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to get customer ESG data" });
    }
  });

  app.get("/api/impact", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });
      const logs = await storage.getEsgImpactLogsByCustomer(userId);
      const totalJobs = logs.length;
      let totalWeightDiverted = 0;
      let totalCo2Saved = 0;
      let donationItems = 0;
      for (const log of logs) {
        const diverted = (log.recycledWeightLbs || 0) + (log.donatedWeightLbs || 0) + (log.eWasteWeightLbs || 0);
        totalWeightDiverted += diverted;
        totalCo2Saved += (log.avoidedEmissionsKg || 0) + (log.routingSavingsKg || 0);
        donationItems += log.donatedWeightLbs && log.donatedWeightLbs > 0 ? 1 : 0;
      }
      const avgDiversionRate = totalJobs > 0
        ? Math.round(logs.reduce((sum, l) => sum + (l.diversionRate || 0), 0) / totalJobs)
        : 0;
      const treesEquivalent = Math.round(logs.reduce((sum, l) => sum + (l.treesEquivalent || 0), 0));
      const serviceRequests = await storage.getServiceRequestsByCustomer(userId);
      const completedJobs = serviceRequests.filter(sr => sr.status === "completed");
      const valueProtected = completedJobs.reduce((sum, sr) => sum + (sr.finalPrice || sr.estimatedPrice || 0), 0);
      const uniqueHaulers = new Set(completedJobs.map(sr => sr.haulerId).filter(Boolean));
      res.json({
        totalJobs,
        totalWeightDiverted: Math.round(totalWeightDiverted),
        totalCo2Saved: Math.round(totalCo2Saved * 10) / 10,
        landfillDiversionRate: Math.min(avgDiversionRate, 100),
        treesEquivalent,
        donationItems,
        valueProtected: Math.round(valueProtected * 100) / 100,
        prosSupported: uniqueHaulers.size,
      });
    } catch (error) {
      console.error("Impact dashboard error:", error);
      res.status(500).json({ error: "Failed to get impact data" });
    }
  });

  // ==========================================
  // AI Circular Economy - Junk Categorization
  // ==========================================
  app.post("/api/ai/categorize-disposal", async (req, res) => {
    try {
      const { items, photoUrls } = req.body;
      if (!items || !Array.isArray(items) || items.length === 0) {
        return res.status(400).json({ error: "Items array required" });
      }
      const categorization = await categorizeItemsForDisposal(items, photoUrls);
      res.json(categorization);
    } catch (error) {
      console.error("Disposal categorization error:", error);
      res.status(500).json({ error: "Failed to categorize items" });
    }
  });

  // ==========================================
  // Dispute Resolution - Before/After Comparison
  // ==========================================
  app.post("/api/disputes", requireAuth, async (req, res) => {
    try {
      const { serviceRequestId, customerId, haulerId, reason, description, photosBefore, photosAfter, damagePhotos } = req.body;
      if (!serviceRequestId || !customerId || !haulerId || !reason) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      const dispute = await storage.createDispute({
        serviceRequestId,
        customerId,
        haulerId,
        reason,
        description: description || null,
        status: "open",
        photosBefore: photosBefore || null,
        photosAfter: photosAfter || null,
        damagePhotos: damagePhotos || null,
        createdAt: new Date().toISOString(),
      });

      if (photosBefore?.length > 0 && photosAfter?.length > 0) {
        try {
          const aiResult = await analyzeDisputePhotos(
            photosBefore || [],
            photosAfter || [],
            damagePhotos || [],
            description || reason
          );

          await storage.updateDispute(dispute.id, {
            aiAnalysisResult: JSON.stringify(aiResult),
            aiConfidence: aiResult.confidence,
            aiRecommendation: aiResult.recommendation,
            aiAnalyzedAt: new Date().toISOString(),
            status: "ai_reviewed",
          });

          return res.json({ dispute: { ...dispute, ...aiResult }, aiAnalysis: aiResult });
        } catch (aiErr) {
          console.error("AI dispute analysis failed, continuing without:", aiErr);
        }
      }

      res.json({ dispute });
    } catch (error) {
      console.error("Dispute creation error:", error);
      res.status(500).json({ error: "Failed to create dispute" });
    }
  });

  app.get("/api/disputes/:id", requireAuth, async (req, res) => {
    try {
      const dispute = await storage.getDispute(req.params.id);
      if (!dispute) return res.status(404).json({ error: "Dispute not found" });
      res.json(dispute);
    } catch (error) {
      res.status(500).json({ error: "Failed to get dispute" });
    }
  });

  app.get("/api/disputes", requireAuth, async (req, res) => {
    try {
      const { status, customerId } = req.query as any;
      let disputesList;
      if (customerId) {
        disputesList = await storage.getDisputesByCustomer(customerId);
      } else if (status) {
        disputesList = await storage.getDisputesByStatus(status);
      } else {
        disputesList = await storage.getDisputesByStatus("open");
      }
      res.json(disputesList);
    } catch (error) {
      res.status(500).json({ error: "Failed to get disputes" });
    }
  });

  app.patch("/api/disputes/:id/resolve", requireAuth, async (req, res) => {
    try {
      const { resolution, refundAmount, resolvedBy } = req.body;
      const dispute = await storage.updateDispute(req.params.id, {
        status: "closed",
        resolution,
        refundAmount: refundAmount || null,
        resolvedBy: resolvedBy || null,
        resolvedAt: new Date().toISOString(),
      });
      if (!dispute) return res.status(404).json({ error: "Dispute not found" });
      res.json(dispute);
    } catch (error) {
      res.status(500).json({ error: "Failed to resolve dispute" });
    }
  });

  // ==========================================
  // Worker Skills - Skill Graph
  // ==========================================
  app.get("/api/worker-skills/:haulerProfileId", async (req, res) => {
    try {
      const skills = await storage.getWorkerSkills(req.params.haulerProfileId);
      res.json(skills);
    } catch (error) {
      res.status(500).json({ error: "Failed to get worker skills" });
    }
  });

  app.post("/api/worker-skills", requireAuth, async (req, res) => {
    try {
      const { haulerProfileId, skillType, rating } = req.body;
      if (!haulerProfileId || !skillType) return res.status(400).json({ error: "Missing required fields" });
      const skill = await storage.upsertWorkerSkill({
        haulerProfileId,
        skillType,
        rating: rating || 5.0,
        createdAt: new Date().toISOString(),
      });
      res.json(skill);
    } catch (error) {
      res.status(500).json({ error: "Failed to update worker skill" });
    }
  });

  // ==========================================
  // Demand Heatmap - Predictive Earnings
  // ==========================================
  app.get("/api/demand-heatmap", async (req, res) => {
    try {
      const { dayOfWeek, hourOfDay } = req.query as any;
      const day = dayOfWeek !== undefined ? parseInt(dayOfWeek) : new Date().getDay();
      const hour = hourOfDay !== undefined ? parseInt(hourOfDay) : new Date().getHours();
      const data = await storage.getDemandHeatmapData(day, hour);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to get demand heatmap data" });
    }
  });

  // ==========================================
  // Verification Gates - Worker Status
  // ==========================================
  app.get("/api/verification-gates/:haulerId", requireAuth, async (req, res) => {
    try {
      const profile = await storage.getHaulerProfile(req.params.haulerId);
      if (!profile) return res.status(404).json({ error: "PYCKER profile not found" });

      const gates = {
        identity: {
          status: profile.selfiePhotoUrl && profile.idPhotoUrl ? "verified" : "pending",
          selfieUploaded: !!profile.selfiePhotoUrl,
          idUploaded: !!profile.idPhotoUrl,
        },
        backgroundCheck: {
          status: profile.backgroundCheckStatus || "pending",
          completedAt: profile.backgroundCheckCompletedAt,
        },
        insurance: {
          generalLiability: {
            status: profile.generalLiabilityDocumentUrl ? "uploaded" : "missing",
            provider: profile.generalLiabilityProvider,
            expiration: profile.generalLiabilityExpiration,
            isExpired: profile.generalLiabilityExpiration ? new Date(profile.generalLiabilityExpiration) < new Date() : true,
          },
          vehicleInsurance: {
            status: profile.vehicleInsuranceDocumentUrl ? "uploaded" : "missing",
            provider: profile.vehicleInsuranceProvider,
            expiration: profile.vehicleInsuranceExpiration,
            isExpired: profile.vehicleInsuranceExpiration ? new Date(profile.vehicleInsuranceExpiration) < new Date() : true,
          },
        },
        nda: {
          signed: !!profile.ndaAcceptedAt,
          version: profile.ndaVersion,
          signedAt: profile.ndaAcceptedAt,
        },
        canAcceptJobs: profile.canAcceptJobs || false,
        pyckerTier: profile.pyckerTier || "independent",
        payoutPercentage: profile.payoutPercentage || 0.75,
      };

      res.json(gates);
    } catch (error) {
      res.status(500).json({ error: "Failed to get verification gates" });
    }
  });

  app.get("/api/payout/breakdown/:haulerId", requireAuth, async (req, res) => {
    try {
      const { haulerId } = req.params;
      const user = req.user as any;
      if (user.id !== haulerId && user.role !== "admin") {
        return res.status(403).json({ error: "Access denied" });
      }
      const amount = parseFloat(req.query.amount as string) || 100;
      const breakdown = await storage.getPayoutBreakdown(haulerId, amount);
      res.json(breakdown);
    } catch (error) {
      res.status(500).json({ error: "Failed to get payout breakdown" });
    }
  });

  app.get("/api/loyalty/status/:userId", requireAuth, async (req, res) => {
    try {
      const requestedUserId = req.params.userId;
      const currentUser = req.user as any;
      if (currentUser.id !== requestedUserId && currentUser.role !== "admin") {
        return res.status(403).json({ error: "Access denied" });
      }

      const user = await storage.getUser(requestedUserId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const completedJobs = user.totalJobsCompleted || 0;
      let tier = 'new';
      let discountPercent = 0;
      let nextTierAt: number | null = 3;

      if (completedJobs >= 10) {
        tier = 'gold';
        discountPercent = 2;
        nextTierAt = null;
      } else if (completedJobs >= 5) {
        tier = 'silver';
        discountPercent = 2;
        nextTierAt = 10;
      } else if (completedJobs >= 3) {
        tier = 'bronze';
        discountPercent = 2;
        nextTierAt = 5;
      }

      res.json({
        userId: user.id,
        totalJobsCompleted: completedJobs,
        tier,
        discountPercent,
        nextTierAt,
        jobsUntilNextTier: nextTierAt ? Math.max(0, nextTierAt - completedJobs) : 0,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get loyalty status" });
    }
  });

  app.get("/api/loyalty/worker-status/:haulerId", requireAuth, async (req, res) => {
    try {
      const currentUser = req.user as any;
      if (currentUser.id !== req.params.haulerId && currentUser.role !== "admin") {
        return res.status(403).json({ error: "Access denied" });
      }

      const profile = await storage.getHaulerProfile(req.params.haulerId);
      if (!profile) {
        return res.status(404).json({ error: "Worker not found" });
      }

      const fiveStarCount = profile.fiveStarJobCount || 0;
      const hasPriorityBoost = profile.loyaltyPriorityBoost || false;

      res.json({
        haulerId: profile.userId,
        fiveStarJobCount: fiveStarCount,
        hasPriorityBoost,
        fiveStarJobsUntilBoost: hasPriorityBoost ? 0 : Math.max(0, 10 - fiveStarCount),
        isVerifiedLlc: profile.isVerifiedLlc || false,
        pyckerTier: profile.pyckerTier || 'independent',
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get worker loyalty status" });
    }
  });

  // ==========================================
  // Green Guarantee Rebate - Disposal Receipt Verification
  // ==========================================
  app.post("/api/green-rebate/submit", requireAuth, async (req, res) => {
    try {
      const { receiptImageUrl, jobId } = req.body;
      const user = req.user as any;
      const haulerId = user.id;

      if (!receiptImageUrl) {
        return res.status(400).json({ error: "receiptImageUrl is required" });
      }

      const profile = await storage.getHaulerProfile(haulerId);
      if (!profile) {
        return res.status(403).json({ error: "Only PYCKERs can submit disposal receipts" });
      }

      const { canClaim, reason } = await storage.canClaimDailyBonus(haulerId);
      if (!canClaim) {
        return res.status(400).json({ error: reason, dailyLimitReached: true });
      }

      const crypto = await import("crypto");
      const receiptHash = crypto.createHash("sha256").update(receiptImageUrl).digest("hex");

      const isDuplicate = await storage.checkDuplicateReceipt(receiptHash);
      if (isDuplicate) {
        return res.status(400).json({ error: "This receipt has already been submitted", duplicate: true });
      }

      let verification;
      try {
        verification = await verifyDisposalReceipt(receiptImageUrl);
      } catch (e) {
        console.error("AI verification failed:", e);
        verification = null;
      }

      const isApproved = verification && verification.isDisposalReceipt && verification.confidence >= 0.7 && verification.isValidDate !== false;

      const receipt = await storage.createDisposalReceipt({
        haulerId,
        jobId: jobId || null,
        receiptImageUrl,
        facilityName: verification?.facilityName || null,
        receiptDate: verification?.receiptDate || null,
        amountPaid: verification?.amountPaid || null,
        bonusAmount: 20,
        bonusStatus: isApproved ? "approved" : "pending",
        aiVerified: isApproved || false,
        aiConfidence: verification?.confidence || null,
        aiExtractedData: verification ? JSON.stringify(verification) : null,
        rejectionReason: !isApproved && verification?.rejectionReason ? verification.rejectionReason : null,
        receiptHash,
        createdAt: new Date().toISOString(),
      });

      if (isApproved) {
        await storage.approveDisposalReceipt(receipt.id);
        await storage.addRebateToBalance(profile.id, 20);
      }

      res.json({
        receipt,
        verification: {
          isApproved,
          facilityName: verification?.facilityName,
          confidence: verification?.confidence,
          rejectionReason: !isApproved ? (verification?.rejectionReason || "Needs manual review") : undefined,
        },
        bonusStatus: isApproved ? "approved" : "pending_review",
        bonusAmount: isApproved ? 20 : 0,
        message: isApproved
          ? "Receipt verified! $20 Green Guarantee bonus approved."
          : "Receipt submitted for manual review. We'll verify it shortly.",
      });
    } catch (error) {
      console.error("Green rebate submission error:", error);
      res.status(500).json({ error: "Failed to submit disposal receipt" });
    }
  });

  app.get("/api/green-rebate/status/:haulerId", requireAuth, async (req, res) => {
    try {
      const currentUser = req.user as any;
      if (currentUser.id !== req.params.haulerId && currentUser.role !== "admin") {
        return res.status(403).json({ error: "Access denied" });
      }

      const [bonusCheck, stats] = await Promise.all([
        storage.canClaimDailyBonus(req.params.haulerId),
        storage.getDisposalReceiptStats(req.params.haulerId),
      ]);

      res.json({
        haulerId: req.params.haulerId,
        canClaimToday: bonusCheck.canClaim,
        approvedBonusesToday: bonusCheck.approvedToday,
        dailyBonusAmount: 20,
        ...stats,
        monthlyEstimate: `$${Math.min(stats.approvedReceipts * 20, 500)}`,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get green rebate status" });
    }
  });

  app.get("/api/green-rebate/history/:haulerId", requireAuth, async (req, res) => {
    try {
      const currentUser = req.user as any;
      if (currentUser.id !== req.params.haulerId && currentUser.role !== "admin") {
        return res.status(403).json({ error: "Access denied" });
      }

      const receipts = await storage.getDisposalReceiptsByHauler(req.params.haulerId);
      res.json(receipts);
    } catch (error) {
      res.status(500).json({ error: "Failed to get green rebate history" });
    }
  });

  // ==========================================
  // Carbon-Intelligent Dispatcher
  // ==========================================
  app.post("/api/dispatch/optimize", requireAuth, async (req, res) => {
    try {
      const pendingRequests = await storage.getPendingRequests();
      const jobs: DispatchRoute[] = pendingRequests
        .filter(r => r.pickupLat && r.pickupLng)
        .map(r => ({
          jobId: r.id,
          pickupLat: r.pickupLat!,
          pickupLng: r.pickupLng!,
          estimatedDistanceMiles: 5,
        }));

      const batches = calculateCarbonOptimizedBatches(jobs);

      const savedBatches = [];
      for (const batch of batches) {
        const saved = await storage.createDispatchBatch({
          batchDate: new Date().toISOString().split("T")[0],
          region: batch.region,
          jobIds: JSON.stringify(batch.batchedJobs),
          totalDistanceMiles: batch.totalDistanceMiles,
          optimizedDistanceMiles: batch.optimizedDistanceMiles,
          deadheadMilesSaved: batch.deadheadMilesSaved,
          co2SavedLbs: batch.co2SavedLbs,
          discountOffered: batch.discountSuggestion,
          status: "proposed",
          createdAt: new Date().toISOString(),
        });
        savedBatches.push(saved);
      }

      const totalSaved = batches.reduce((s, b) => s + b.co2SavedLbs, 0);
      const totalDeadheadSaved = batches.reduce((s, b) => s + b.deadheadMilesSaved, 0);

      res.json({
        batches: savedBatches,
        summary: {
          totalBatches: batches.length,
          totalJobsBatched: batches.reduce((s, b) => s + b.batchedJobs.length, 0),
          totalCo2SavedLbs: totalSaved,
          totalDeadheadMilesSaved: totalDeadheadSaved,
          avgDiscountPerJob: batches.length > 0 ? batches.reduce((s, b) => s + b.discountSuggestion, 0) / batches.length : 0,
        },
      });
    } catch (error) {
      console.error("Dispatch optimization error:", error);
      res.status(500).json({ error: "Failed to optimize dispatch" });
    }
  });

  app.get("/api/dispatch/batches", requireAuth, async (req, res) => {
    try {
      const date = (req.query.date as string) || new Date().toISOString().split("T")[0];
      const batches = await storage.getDispatchBatchesByDate(date);
      res.json(batches);
    } catch (error) {
      res.status(500).json({ error: "Failed to get dispatch batches" });
    }
  });

  app.get("/api/dispatch/hauler-batches/:haulerId", requireAuth, async (req, res) => {
    try {
      const batches = await storage.getDispatchBatchesByHauler(req.params.haulerId);
      res.json(batches);
    } catch (error) {
      res.status(500).json({ error: "Failed to get hauler batches" });
    }
  });

  app.patch("/api/dispatch/batches/:id", requireAuth, async (req, res) => {
    try {
      const updated = await storage.updateDispatchBatch(req.params.id, req.body);
      if (!updated) return res.status(404).json({ error: "Batch not found" });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update batch" });
    }
  });

  // ==========================================
  // Circular Economy Agent
  // ==========================================
  app.post("/api/circular-economy/classify", requireAuth, async (req, res) => {
    try {
      const { serviceRequestId, photoUrls, itemDescriptions } = req.body;
      if (!serviceRequestId || !itemDescriptions?.length) {
        return res.status(400).json({ error: "serviceRequestId and itemDescriptions are required" });
      }

      const classifications = await classifyItemsForDisposal(photoUrls || [], itemDescriptions);

      const savedRecs = [];
      for (const item of classifications) {
        const rec = await storage.createDisposalRecommendation({
          serviceRequestId,
          itemName: item.itemName,
          category: item.category,
          estimatedWeightLbs: item.estimatedWeightLbs,
          destinationName: item.destinationName,
          destinationAddress: item.destinationAddress,
          estimatedValue: item.estimatedValue,
          co2AvoidedLbs: item.co2AvoidedLbs,
          status: "pending",
          createdAt: new Date().toISOString(),
        });
        savedRecs.push(rec);
      }

      const totalDiverted = classifications.filter(c => c.category !== "landfill").reduce((s, c) => s + c.estimatedWeightLbs, 0);
      const totalCo2Avoided = classifications.reduce((s, c) => s + c.co2AvoidedLbs, 0);

      res.json({
        recommendations: savedRecs,
        summary: {
          totalItems: classifications.length,
          totalDivertedLbs: totalDiverted,
          totalCo2AvoidedLbs: totalCo2Avoided,
          totalEstimatedValue: classifications.reduce((s, c) => s + c.estimatedValue, 0),
          byCategory: {
            donate: classifications.filter(c => c.category === "donate").length,
            recycle: classifications.filter(c => c.category === "recycle").length,
            resell: classifications.filter(c => c.category === "resell").length,
            eWaste: classifications.filter(c => c.category === "e_waste").length,
            hazardous: classifications.filter(c => c.category === "hazardous").length,
            landfill: classifications.filter(c => c.category === "landfill").length,
          },
        },
      });
    } catch (error) {
      console.error("Circular economy classification error:", error);
      res.status(500).json({ error: "Failed to classify items" });
    }
  });

  app.get("/api/circular-economy/recommendations/:serviceRequestId", async (req, res) => {
    try {
      const recs = await storage.getDisposalRecommendationsByRequest(req.params.serviceRequestId);
      res.json(recs);
    } catch (error) {
      res.status(500).json({ error: "Failed to get recommendations" });
    }
  });

  app.patch("/api/circular-economy/recommendations/:id", requireAuth, async (req, res) => {
    try {
      const updated = await storage.updateDisposalRecommendation(req.params.id, req.body);
      if (!updated) return res.status(404).json({ error: "Recommendation not found" });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update recommendation" });
    }
  });

  // ==========================================
  // Compliance Vault - Receipts & Mileage
  // ==========================================
  app.post("/api/compliance/receipts", requireAuth, async (req, res) => {
    try {
      const { haulerId, receiptType, vendorName, amount, receiptDate, receiptImageUrl, category, serviceRequestId } = req.body;
      if (!haulerId || !receiptType || amount === undefined || !receiptDate) {
        return res.status(400).json({ error: "haulerId, receiptType, amount, and receiptDate are required" });
      }

      let aiData = null;
      if (receiptImageUrl) {
        try {
          const scanned = await scanReceipt(receiptImageUrl);
          aiData = JSON.stringify(scanned);
        } catch (e) {
          console.error("Receipt scan failed:", e);
        }
      }

      const receipt = await storage.createComplianceReceipt({
        haulerId,
        serviceRequestId: serviceRequestId || null,
        receiptType,
        vendorName: vendorName || null,
        amount,
        receiptDate,
        receiptImageUrl: receiptImageUrl || null,
        aiExtractedData: aiData,
        taxDeductible: ["fuel", "disposal", "equipment", "insurance", "license"].includes(receiptType),
        category: category || receiptType,
        createdAt: new Date().toISOString(),
      });

      res.json(receipt);
    } catch (error) {
      console.error("Receipt creation error:", error);
      res.status(500).json({ error: "Failed to create receipt" });
    }
  });

  app.get("/api/compliance/receipts/:haulerId", requireAuth, async (req, res) => {
    try {
      const receipts = await storage.getComplianceReceiptsByHauler(req.params.haulerId);
      res.json(receipts);
    } catch (error) {
      res.status(500).json({ error: "Failed to get receipts" });
    }
  });

  app.get("/api/compliance/receipt-summary/:haulerId", requireAuth, async (req, res) => {
    try {
      const year = parseInt(req.query.year as string) || new Date().getFullYear();
      const summary = await storage.getComplianceReceiptSummary(req.params.haulerId, year);
      res.json(summary);
    } catch (error) {
      res.status(500).json({ error: "Failed to get receipt summary" });
    }
  });

  app.post("/api/compliance/mileage", requireAuth, async (req, res) => {
    try {
      const { haulerId, serviceRequestId, startAddress, endAddress, distanceMiles, purpose, tripDate } = req.body;
      if (!haulerId || !distanceMiles || !tripDate) {
        return res.status(400).json({ error: "haulerId, distanceMiles, and tripDate are required" });
      }

      const log = await storage.createMileageLog({
        haulerId,
        serviceRequestId: serviceRequestId || null,
        startAddress: startAddress || null,
        endAddress: endAddress || null,
        distanceMiles,
        purpose: purpose || "business",
        tripDate,
        irsRateCentsPerMile: 67,
        createdAt: new Date().toISOString(),
      });

      res.json(log);
    } catch (error) {
      console.error("Mileage log error:", error);
      res.status(500).json({ error: "Failed to create mileage log" });
    }
  });

  app.get("/api/compliance/mileage/:haulerId", requireAuth, async (req, res) => {
    try {
      const logs = await storage.getMileageLogsByHauler(req.params.haulerId);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to get mileage logs" });
    }
  });

  app.get("/api/compliance/mileage-summary/:haulerId", requireAuth, async (req, res) => {
    try {
      const year = parseInt(req.query.year as string) || new Date().getFullYear();
      const summary = await storage.getMileageSummary(req.params.haulerId, year);
      res.json(summary);
    } catch (error) {
      res.status(500).json({ error: "Failed to get mileage summary" });
    }
  });

  app.get("/api/compliance/tax-summary/:haulerId", requireAuth, async (req, res) => {
    try {
      const year = parseInt(req.query.year as string) || new Date().getFullYear();
      const [receiptSummary, mileageSummary] = await Promise.all([
        storage.getComplianceReceiptSummary(req.params.haulerId, year),
        storage.getMileageSummary(req.params.haulerId, year),
      ]);

      res.json({
        year,
        totalExpenses: receiptSummary.totalExpenses,
        totalDeductibleExpenses: receiptSummary.totalDeductible,
        expensesByCategory: receiptSummary.byCategory,
        totalMiles: mileageSummary.totalMiles,
        businessMiles: mileageSummary.businessMiles,
        mileageDeduction: mileageSummary.totalDeduction,
        totalDeductions: receiptSummary.totalDeductible + mileageSummary.totalDeduction,
        irsStandardRate: "$0.67/mile",
        estimatedTaxSavings: (receiptSummary.totalDeductible + mileageSummary.totalDeduction) * 0.22,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get tax summary" });
    }
  });

  // ==========================================
  // B2B Scope 3 ESG Reports
  // ==========================================
  app.post("/api/esg/generate-report", requireAuth, async (req, res) => {
    try {
      const { businessAccountId, month, year } = req.body;
      if (!businessAccountId || !month || !year) {
        return res.status(400).json({ error: "businessAccountId, month, and year are required" });
      }

      const esgSummary = await storage.getEsgSummary();

      const ledger = {
        co2_saved_kg: (esgSummary.totalCarbonLbs * 0.453592) * 0.3,
        landfill_diversion_lbs: esgSummary.totalDivertedLbs,
        tax_credits_unlocked_usd: esgSummary.totalDivertedLbs > 0 ? Math.round(esgSummary.totalDivertedLbs * 0.15) : 0,
        water_saved_gallons: esgSummary.totalJobs * 12.5,
      };

      const report = await storage.createEsgReport({
        businessAccountId,
        reportMonth: month,
        reportYear: year,
        totalJobsCount: esgSummary.totalJobs,
        co2SavedKg: ledger.co2_saved_kg,
        landfillDiversionLbs: ledger.landfill_diversion_lbs,
        taxCreditsUnlockedUsd: ledger.tax_credits_unlocked_usd,
        waterSavedGallons: ledger.water_saved_gallons,
        energySavedKwh: esgSummary.totalJobs * 8.5,
        totalCarbonFootprintLbs: esgSummary.totalCarbonLbs,
        deadheadMilesSaved: 0,
        circularEconomyLbs: esgSummary.totalDivertedLbs,
        auditReady: true,
        reportData: JSON.stringify({
          ledger,
          generatedBy: "UpTend ProofGreen Engine",
          standard: "GHG Protocol Scope 3",
          methodology: "Activity-based approach with emission factors from EPA WARM model",
          period: `${year}-${String(month).padStart(2, "0")}`,
          disclaimer: "This report is generated for informational purposes. Consult a certified auditor for official ESG reporting.",
        }),
        generatedAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
      });

      res.json({ report, ledger });
    } catch (error) {
      console.error("ESG report generation error:", error);
      res.status(500).json({ error: "Failed to generate ESG report" });
    }
  });

  app.get("/api/esg/reports/:businessAccountId", requireAuth, async (req, res) => {
    try {
      const reports = await storage.getEsgReportsByBusiness(req.params.businessAccountId);
      res.json(reports);
    } catch (error) {
      res.status(500).json({ error: "Failed to get ESG reports" });
    }
  });

  app.get("/api/esg/report/:id", requireAuth, async (req, res) => {
    try {
      const report = await storage.getEsgReport(req.params.id);
      if (!report) return res.status(404).json({ error: "Report not found" });
      res.json(report);
    } catch (error) {
      res.status(500).json({ error: "Failed to get report" });
    }
  });

  // ==========================================
  // Tax Credit Eligibility
  // ==========================================
  app.post("/api/tax-credits/check-eligibility", requireAuth, async (req, res) => {
    try {
      const { serviceType, itemDescriptions, totalWeight, diversionRate } = req.body;
      const eligibility = await analyzeTaxCreditEligibility(
        serviceType || "junk_removal",
        itemDescriptions || [],
        totalWeight || 0,
        diversionRate || 0
      );
      res.json(eligibility);
    } catch (error) {
      res.status(500).json({ error: "Failed to check tax credit eligibility" });
    }
  });

  // ESG Ledger endpoint - returns the standard format
  app.get("/api/platform/sustainability-stats", async (_req, res) => {
    try {
      const stats = await storage.getPlatformSustainabilityStats();
      if (!stats) {
        return res.json({
          totalJobsAudited: 0,
          totalCo2SavedKg: 0,
          totalCo2SavedTonnes: 0,
          totalCo2EmittedKg: 0,
          totalLandfillDivertedLbs: 0,
          totalRecycledLbs: 0,
          totalDonatedLbs: 0,
          totalEwasteLbs: 0,
          treesEquivalent: 0,
          waterSavedGallons: 0,
          energySavedKwh: 0,
          avgDiversionRate: 0,
          deadheadMilesSaved: 0,
          lastAuditedAt: null,
        });
      }
      res.json({
        ...stats,
        totalCo2SavedTonnes: parseFloat(((stats.totalCo2SavedKg || 0) / 1000).toFixed(3)),
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get sustainability stats" });
    }
  });

  app.get("/api/esg/ledger/:serviceRequestId", async (req, res) => {
    try {
      const impactLog = await storage.getEsgImpactLogByRequest(req.params.serviceRequestId);
      if (!impactLog) {
        return res.json({
          co2_saved_kg: 0,
          landfill_diversion_lbs: 0,
          tax_credits_unlocked_usd: 0,
          water_saved_gallons: 0,
        });
      }

      const co2SavedKg = ((impactLog.recycledWeightLbs + impactLog.donatedWeightLbs) * 0.5 * 0.453592);
      const taxCredits = impactLog.diversionRate > 0.5 ? Math.round(impactLog.totalWeightLbs * 0.15) : 0;

      res.json({
        co2_saved_kg: parseFloat(co2SavedKg.toFixed(2)),
        landfill_diversion_lbs: (impactLog.recycledWeightLbs || 0) + (impactLog.donatedWeightLbs || 0),
        tax_credits_unlocked_usd: taxCredits,
        water_saved_gallons: impactLog.waterSavedGallons || 0,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get ESG ledger" });
    }
  });

  // ==========================================
  // PII Reveal Audit Logging
  // ==========================================
  app.post("/api/audit/pii-reveal", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const { fieldType, resourceId } = req.body;

      if (!fieldType || !resourceId) {
        return res.status(400).json({ error: "fieldType and resourceId are required" });
      }

      await logAuditEvent(
        user.id,
        user.role || "user",
        "VIEW_PII",
        resourceId,
        { fieldType, revealedAt: new Date().toISOString() },
        req.ip || undefined,
        req.headers["user-agent"] || undefined
      );

      res.json({ logged: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to log PII reveal" });
    }
  });

  // ==========================================
  // Audit Log Viewer (Admin Only)
  // ==========================================
  app.get("/api/admin/audit-logs", requireAdminSession, async (req, res) => {
    try {
      const { desc } = await import("drizzle-orm");
      const limit = parseInt(req.query.limit as string) || 100;
      const logs = await db.select().from(auditLogs)
        .orderBy(desc(auditLogs.timestamp))
        .limit(limit);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to get audit logs" });
    }
  });

  // ==========================================
  // Compliance Health Endpoint (Vanta/Drata)
  // ==========================================
  app.get("/api/compliance/health", async (_req, res) => {
    try {
      const auditCount = await db.select({ count: sql`count(*)` }).from(auditLogs);
      const lastAuditEntry = await db.select().from(auditLogs)
        .orderBy(sql`${auditLogs.timestamp} DESC`)
        .limit(1);

      res.json({
        status: "healthy",
        db_backup_status: "Continuous replication via Neon (point-in-time recovery enabled)",
        admin_mfa_enabled: true,
        encryption_status: "AES-256 at rest, TLS 1.3 in transit",
        audit_logging: {
          enabled: true,
          total_entries: parseInt((auditCount[0] as any)?.count || "0"),
          last_entry_at: lastAuditEntry[0]?.timestamp || null,
        },
        pii_masking: {
          enabled: true,
          masked_fields: ["phone_number", "gate_code", "access_notes"],
          reveal_requires_audit: true,
        },
        data_retention: {
          audit_logs: "7 years (SOC 2 compliant)",
          pii_data: "Encrypted, access-controlled",
        },
        compliance_frameworks: ["SOC 2 Type II", "GDPR", "CCPA"],
        checked_at: new Date().toISOString(),
      });
    } catch (error) {
      res.status(500).json({ status: "error", error: "Health check failed" });
    }
  });

  // ==========================================
  // Insurance Vault - Digital Home Inventory
  // ==========================================
  app.post("/api/inventory/generate/:serviceRequestId", isAuthenticated, async (req: any, res) => {
    try {
      const { serviceRequestId } = req.params;
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const request = await storage.getServiceRequest(serviceRequestId);
      if (!request) return res.status(404).json({ error: "Service request not found" });

      if (request.customerId !== userId) {
        const user = await storage.getUser(userId);
        if (user?.role !== "admin") {
          return res.status(403).json({ error: "Not authorized" });
        }
      }

      if (!request.photoUrls || request.photoUrls.length === 0) {
        return res.status(400).json({ error: "No photos available for inventory analysis" });
      }

      const existing = await storage.getHomeInventoryByServiceRequest(serviceRequestId);
      if (existing.length > 0) {
        return res.json({ items: existing, message: "Inventory already generated" });
      }

      const catalogedItems = await catalogItemsForInsurance(request.photoUrls);
      const savedItems = [];
      for (const item of catalogedItems) {
        const saved = await storage.createHomeInventoryItem({
          customerId: request.customerId,
          serviceRequestId,
          itemName: item.itemName,
          estimatedValue: item.estimatedValue,
          brandDetected: item.brandDetected,
          condition: item.condition,
          photoUrl: request.photoUrls[0] || null,
          generatedAt: new Date().toISOString(),
        });
        savedItems.push(saved);
      }

      res.json({ items: savedItems, message: `${savedItems.length} items cataloged for insurance` });
    } catch (error) {
      console.error("Error generating inventory:", error);
      res.status(500).json({ error: "Failed to generate inventory" });
    }
  });

  app.get("/api/inventory/customer/:customerId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      const { customerId } = req.params;
      if (userId !== customerId) {
        const user = await storage.getUser(userId);
        if (user?.role !== "admin") return res.status(403).json({ error: "Not authorized" });
      }
      const items = await storage.getHomeInventoryByCustomer(customerId);
      res.json(items);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch inventory" });
    }
  });

  app.get("/api/inventory/job/:serviceRequestId", isAuthenticated, async (req: any, res) => {
    try {
      const items = await storage.getHomeInventoryByServiceRequest(req.params.serviceRequestId);
      res.json(items);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch inventory" });
    }
  });

  // ==========================================
  // Reseller Marketplace - Claim for Resale
  // ==========================================
  app.post("/api/inventory/:itemId/claim-resale", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const user = await storage.getUser(userId);
      if (user?.role !== "hauler" && user?.role !== "admin") {
        return res.status(403).json({ error: "Only PYCKERs can claim items for resale" });
      }

      const items = await storage.getHomeInventoryByServiceRequest(req.body.serviceRequestId || "");
      const item = items.find(i => i.id === req.params.itemId);
      if (!item) return res.status(404).json({ error: "Item not found" });

      const description = generateResaleDescription(item);
      const updated = await storage.updateHomeInventoryItem(req.params.itemId, {
        resaleStatus: "claimed_for_resale",
        resaleDescription: description,
        resaleListingUrl: req.body.listingUrl || null,
      });

      res.json({ item: updated, resaleDescription: description });
    } catch (error) {
      res.status(500).json({ error: "Failed to claim item for resale" });
    }
  });

  app.patch("/api/inventory/:itemId/status", isAuthenticated, async (req: any, res) => {
    try {
      const { status } = req.body;
      if (!["disposal", "claimed_for_resale", "donated", "recycled"].includes(status)) {
        return res.status(400).json({ error: "Invalid status" });
      }
      const updated = await storage.updateHomeInventoryItem(req.params.itemId, {
        resaleStatus: status,
        resaleListingUrl: req.body.listingUrl || null,
      });
      if (!updated) return res.status(404).json({ error: "Item not found" });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update item status" });
    }
  });

  // ==========================================
  // Smart Lock Integration - Access Codes
  // ==========================================
  app.patch("/api/service-requests/:id/access-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      const request = await storage.getServiceRequest(req.params.id);
      if (!request) return res.status(404).json({ error: "Service request not found" });

      if (request.customerId !== userId) {
        const user = await storage.getUser(userId);
        if (user?.role !== "admin") return res.status(403).json({ error: "Not authorized" });
      }

      const { accessType, accessCode, accessWindowStart, accessWindowEnd } = req.body;
      const updated = await storage.updateServiceRequest(req.params.id, {
        accessType: accessType || "smart_lock",
        encryptedAccessCode: accessCode,
        accessWindowStart: accessWindowStart || null,
        accessWindowEnd: accessWindowEnd || null,
      });

      res.json({ message: "Access code saved", accessType: updated?.accessType });
    } catch (error) {
      res.status(500).json({ error: "Failed to save access code" });
    }
  });

  app.get("/api/service-requests/:id/access-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      const request = await storage.getServiceRequest(req.params.id);
      if (!request) return res.status(404).json({ error: "Service request not found" });

      if (request.accessType === "person" || !request.encryptedAccessCode) {
        return res.json({ accessType: "person", code: null });
      }

      const user = await storage.getUser(userId);
      const isAdmin = user?.role === "admin";
      const isAssignedHauler = request.assignedHaulerId === userId;
      const isCustomer = request.customerId === userId;

      if (!isAdmin && !isCustomer && !isAssignedHauler) {
        return res.status(403).json({ error: "Not authorized" });
      }

      if (isAssignedHauler) {
        const allowedStatuses = ["en_route", "in_progress", "assigned"];
        if (!allowedStatuses.includes(request.status)) {
          return res.json({
            accessType: request.accessType,
            code: null,
            message: "Access code available when job is en route or in progress",
          });
        }
      }

      res.json({
        accessType: request.accessType,
        code: request.encryptedAccessCode,
        accessWindowStart: request.accessWindowStart,
        accessWindowEnd: request.accessWindowEnd,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get access code" });
    }
  });

  // ==========================================
  // Carbon Offset Upsell
  // ==========================================
  app.patch("/api/service-requests/:id/carbon-offset", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.localAuth ? req.user.userId : req.user.claims?.sub;
      const request = await storage.getServiceRequest(req.params.id);
      if (!request) return res.status(404).json({ error: "Service request not found" });
      if (request.customerId !== userId) return res.status(403).json({ error: "Not authorized" });

      const optIn = req.body.carbonOffsetOptIn === true;
      const CARBON_OFFSET_FEE_CENTS = 499;
      const updated = await storage.updateServiceRequest(req.params.id, {
        carbonOffsetOptIn: optIn,
        carbonOffsetFee: optIn ? CARBON_OFFSET_FEE_CENTS : 0,
      });

      res.json({
        carbonOffsetOptIn: updated?.carbonOffsetOptIn,
        carbonOffsetFee: updated?.carbonOffsetFee,
        message: optIn ? "Carbon offset added ($4.99)" : "Carbon offset removed",
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to update carbon offset" });
    }
  });

  // ==========================================
  // FIELD AUDIT: Worker locks price before starting
  // ==========================================
  app.post("/api/service-requests/:id/lock-price", requireAuth, requireHauler, async (req, res) => {
    try {
      const userId = (req.user as any).id;
      const jobId = req.params.id;
      const { newPrice, reason, lineItems } = req.body;

      const job = await storage.getServiceRequest(jobId);
      if (!job) return res.status(404).json({ error: "Job not found" });
      if (job.assignedHaulerId !== userId) return res.status(403).json({ error: "Not assigned to this job" });
      if (job.isPriceLocked) return res.status(400).json({ error: "Price already locked" });

      if (typeof newPrice !== "number" || newPrice <= 0) {
        return res.status(400).json({ error: "Invalid price" });
      }

      if (newPrice > (job.priceEstimate || 0) * 2) {
        console.warn(`[PriceAlert] Worker doubled price on job ${jobId}: ${job.priceEstimate} -> ${newPrice}`);
        await logAuditEvent(userId, "hauler", "field_audit_price_alert", `job_${jobId}`, {
          originalPrice: job.priceEstimate,
          newPrice,
          reason,
        });
      }

      const updated = await storage.updateServiceRequest(jobId, {
        finalLockedPrice: Math.round(newPrice * 100),
        originalAiPrice: Math.round((job.priceEstimate || 0) * 100),
        adjustmentReason: reason || null,
        addedLineItems: lineItems ? JSON.stringify(lineItems) : null,
        isPriceLocked: true,
        status: "in_progress",
        startedAt: new Date().toISOString(),
      });

      broadcastToJob(jobId, {
        type: "price_locked",
        originalPrice: job.priceEstimate,
        newPrice,
        lineItems,
        reason,
      });

      await logAuditEvent(userId, "hauler", "field_audit_lock_price", `job_${jobId}`, {
        originalPrice: job.priceEstimate,
        newPrice,
        reason,
        lineItems,
      });

      res.json(updated);
    } catch (error) {
      console.error("Error locking price:", error);
      res.status(500).json({ error: "Failed to lock price" });
    }
  });

  // ==========================================
  // GHOST BUSTER: Mark job arrived timestamp
  // ==========================================
  app.post("/api/service-requests/:id/mark-arrived", requireAuth, requireHauler, async (req, res) => {
    try {
      const userId = (req.user as any).id;
      const jobId = req.params.id;

      const job = await storage.getServiceRequest(jobId);
      if (!job) return res.status(404).json({ error: "Job not found" });
      if (job.assignedHaulerId !== userId) return res.status(403).json({ error: "Not assigned" });

      const updated = await storage.updateServiceRequest(jobId, {
        arrivedAt: new Date().toISOString(),
        status: "arrived",
      });

      broadcastToJob(jobId, { type: "worker_arrived", jobId, arrivedAt: updated?.arrivedAt });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to mark arrival" });
    }
  });

  // ==========================================
  // GHOST BUSTER: Enhanced cancel with ghost detection
  // ==========================================
  app.post("/api/service-requests/:id/customer-cancel", requireAuth, async (req, res) => {
    try {
      const jobId = req.params.id;
      const userId = (req.user as any).id;
      const { reason } = req.body;

      const job = await storage.getServiceRequest(jobId);
      if (!job) return res.status(404).json({ error: "Job not found" });
      if (job.customerId !== userId) return res.status(403).json({ error: "Not your job" });

      const isSuspicious = job.status === "arrived" || job.arrivedAt !== null;

      if (isSuspicious && job.assignedHaulerId) {
        console.warn(`[GHOST DETECTED] Job ${jobId} cancelled while worker on-site.`);

        await db.update(serviceRequests)
          .set({ isGhostFlagged: true })
          .where(eq(serviceRequests.id, jobId));

        await db.execute(sql`
          INSERT INTO hauler_risk_profile (id, hauler_id, ghost_incidents, risk_score, last_incident_at)
          VALUES (gen_random_uuid(), ${job.assignedHaulerId}, 1, 30, ${new Date().toISOString()})
          ON CONFLICT (hauler_id)
          DO UPDATE SET
            ghost_incidents = hauler_risk_profile.ghost_incidents + 1,
            risk_score = hauler_risk_profile.risk_score + 30,
            last_incident_at = ${new Date().toISOString()}
        `);

        await logAuditEvent(userId, "customer", "ghost_detection_flagged", `job_${jobId}`, {
          haulerId: job.assignedHaulerId,
          status: job.status,
          arrivedAt: job.arrivedAt,
        });
      }

      const updated = await storage.updateServiceRequest(jobId, {
        status: "cancelled",
        cancelledAt: new Date().toISOString(),
        cancelledBy: "customer",
        cancellationReason: reason || "Customer cancelled",
        isGhostFlagged: isSuspicious,
      });

      broadcastToJob(jobId, { type: "job_cancelled", cancelledBy: "customer", reason });
      res.json({ success: true, request: updated, ghostFlagged: isSuspicious });
    } catch (error) {
      console.error("Error cancelling job:", error);
      res.status(500).json({ error: "Failed to cancel job" });
    }
  });

  // ==========================================
  // GHOST BUSTER: Get hauler risk profile
  // ==========================================
  app.get("/api/hauler-risk/:haulerId", requireAuth, requireAdmin, async (req, res) => {
    try {
      const [profile] = await db.select()
        .from(haulerRiskProfile)
        .where(eq(haulerRiskProfile.haulerId, req.params.haulerId));
      res.json(profile || { ghostIncidents: 0, keywordsDetected: 0, riskScore: 0 });
    } catch (error) {
      res.status(500).json({ error: "Failed to get risk profile" });
    }
  });

  // ==========================================
  // INSURANCE GATE: Check insurance status for a job
  // ==========================================
  app.get("/api/service-requests/:id/insurance", requireAuth, async (req, res) => {
    try {
      const job = await storage.getServiceRequest(req.params.id);
      if (!job) return res.status(404).json({ error: "Job not found" });

      const INSURANCE_MODE = process.env.INSURANCE_MODE || "BLANKET_ARBITRAGE";

      if (INSURANCE_MODE === "BLANKET_ARBITRAGE") {
        res.json({
          covered: true,
          provider: "UpTend",
          feeToWorker: 2500,
          actionRequired: false,
          mode: "blanket",
        });
      } else {
        const hasCoverage = !!job.externalPolicyId;
        res.json({
          covered: hasCoverage,
          provider: hasCoverage ? "Thimble" : null,
          feeToWorker: 0,
          actionRequired: !hasCoverage,
          purchaseLink: !hasCoverage ? `https://thimble.com/buy?partner=upyck&job=${job.id}` : null,
          mode: "external",
        });
      }
    } catch (error) {
      res.status(500).json({ error: "Failed to check insurance" });
    }
  });

  // ==========================================
  // AGENT API: Headless Booking for AI Agents
  // ==========================================
  app.post("/api/agent/book", async (req, res) => {
    const agentKey = req.headers["x-agent-key"];
    if (agentKey !== process.env.AGENT_API_KEY) {
      return res.status(401).json({ error: "Unauthorized Agent" });
    }

    try {
      const { address, items, date, serviceType } = req.body;
      if (!address) return res.status(400).json({ error: "Address is required" });

      const itemsList = Array.isArray(items) ? items : [];
      const estimatedPrice = Math.max(79, itemsList.length * 25 + 49);

      const job = await storage.createServiceRequest({
        customerId: "agent_user",
        serviceType: serviceType || "junk_removal",
        status: "requested",
        pickupAddress: address,
        pickupCity: "",
        pickupZip: "",
        loadEstimate: "medium",
        scheduledFor: date || "",
        priceEstimate: estimatedPrice,
        isAgentBooking: true,
        description: `Agent booking: ${itemsList.join(", ")}`,
        createdAt: new Date().toISOString(),
      });

      res.json({
        job_id: job.id,
        price: estimatedPrice,
        insurance_policy: "UPYCK-LIABILITY-2026",
        status: "searching_for_worker",
      });
    } catch (error) {
      console.error("Agent booking error:", error);
      res.status(500).json({ error: "Failed to create agent booking" });
    }
  });

  // ==========================================
  // PROPERTY HISTORY: Get or create property record
  // ==========================================
  app.get("/api/properties/:addressHash", requireAuth, async (req, res) => {
    try {
      const [property] = await db.select()
        .from(properties)
        .where(eq(properties.addressHash, req.params.addressHash));
      if (!property) return res.status(404).json({ error: "Property not found" });

      const events = await db.select()
        .from(propertyEvents)
        .where(eq(propertyEvents.propertyId, property.id));

      res.json({ property, events });
    } catch (error) {
      res.status(500).json({ error: "Failed to get property" });
    }
  });

  // ==========================================
  // PROPERTY HISTORY: Generate maintenance report
  // ==========================================
  app.get("/api/properties/:addressHash/report", requireAuth, async (req, res) => {
    try {
      const [property] = await db.select()
        .from(properties)
        .where(eq(properties.addressHash, req.params.addressHash));
      if (!property) return res.status(404).json({ error: "Property not found" });

      const userId = (req.user as any).id;
      if (property.ownerId !== userId) return res.status(403).json({ error: "Not property owner" });

      const events = await db.select()
        .from(propertyEvents)
        .where(eq(propertyEvents.propertyId, property.id));

      res.json({
        badge: property.maintenanceScore && property.maintenanceScore >= 80 ? "UpTend Gold Certified" : "UpTend Verified",
        maintenance_score: property.maintenanceScore,
        address: property.fullAddress,
        last_major_service: events.length > 0 ? events[events.length - 1].description : null,
        verified_value_add: `+$${property.estimatedValueIncrease || 0} in documented services`,
        events: events.map(e => ({
          type: e.eventType,
          description: e.description,
          date: e.date,
          verifiedBy: e.verifiedBy,
          isTransferable: e.isTransferable,
        })),
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to generate report" });
    }
  });

  // ==========================================
  // PROPERTY HISTORY: Auto-create event on job completion
  // ==========================================
  app.post("/api/properties/record-event", requireAuth, async (req, res) => {
    try {
      const { jobId } = req.body;
      const job = await storage.getServiceRequest(jobId);
      if (!job) return res.status(404).json({ error: "Job not found" });
      if (job.status !== "completed") return res.status(400).json({ error: "Job not completed" });

      const addressHash = crypto.createHash("sha256").update(job.pickupAddress.toLowerCase().trim()).digest("hex").substring(0, 16);

      let [property] = await db.select()
        .from(properties)
        .where(eq(properties.addressHash, addressHash));

      if (!property) {
        const [created] = await db.insert(properties).values({
          addressHash,
          fullAddress: job.pickupAddress,
          ownerId: job.customerId,
          maintenanceScore: 10,
          lastAssessmentDate: new Date().toISOString(),
        }).returning();
        property = created;
      }

      const serviceDescriptions: Record<string, string> = {
        junk_removal: "Junk Removal & Cleanout",
        furniture_moving: "Furniture Moving Service",
        garage_cleanout: "Complete Garage Cleanout",
        estate_cleanout: "Estate Cleanout Service",
      };

      const [event] = await db.insert(propertyEvents).values({
        propertyId: property.id,
        serviceRequestId: jobId,
        eventType: "maintenance",
        description: serviceDescriptions[job.serviceType] || job.serviceType,
        verifiedBy: `UpTend Pro (Job #${jobId.substring(0, 8)})`,
        date: new Date().toISOString(),
        isTransferable: true,
      }).returning();

      const newScore = Math.min(100, (property.maintenanceScore || 0) + 10);
      await db.update(properties)
        .set({
          maintenanceScore: newScore,
          lastAssessmentDate: new Date().toISOString(),
          estimatedValueIncrease: (property.estimatedValueIncrease || 0) + Math.round((job.priceEstimate || 0) * 0.5),
        })
        .where(eq(properties.id, property.id));

      res.json({ property, event });
    } catch (error) {
      console.error("Error recording property event:", error);
      res.status(500).json({ error: "Failed to record property event" });
    }
  });

  // ==========================================
  // SAFECOMMS: Get chat messages for a job
  // ==========================================
  app.get("/api/chat/:jobId", requireAuth, async (req, res) => {
    try {
      const msgs = await db.select()
        .from(chatMessages)
        .where(eq(chatMessages.jobId, req.params.jobId));
      res.json(msgs);
    } catch (error) {
      res.status(500).json({ error: "Failed to get messages" });
    }
  });

  // ==========================================
  // PROPERTY TRANSFER: Get user's properties
  // ==========================================
  app.get("/api/properties/my-properties", requireAuth, async (req, res) => {
    try {
      const userId = (req.user as any).id;
      const userProperties = await db.select()
        .from(properties)
        .where(eq(properties.ownerId, userId));

      const propertiesWithTransfers = await Promise.all(
        userProperties.map(async (prop) => {
          const transfers = await db.select()
            .from(propertyTransfers)
            .where(eq(propertyTransfers.propertyId, prop.id));
          return { ...prop, transfers };
        })
      );

      res.json(propertiesWithTransfers);
    } catch (error) {
      console.error("Error getting user properties:", error);
      res.status(500).json({ error: "Failed to get properties" });
    }
  });

  // ==========================================
  // PROPERTY TRANSFER: Initiate transfer (send email to buyer)
  // ==========================================
  app.post("/api/properties/:addressHash/transfer", requireAuth, async (req, res) => {
    try {
      const userId = (req.user as any).id;
      const user = req.user as any;
      const { buyerEmail } = req.body;

      if (!buyerEmail || !buyerEmail.includes("@")) {
        return res.status(400).json({ error: "Valid buyer email is required" });
      }

      const [property] = await db.select()
        .from(properties)
        .where(eq(properties.addressHash, req.params.addressHash));

      if (!property) return res.status(404).json({ error: "Property not found" });
      if (property.ownerId !== userId) return res.status(403).json({ error: "Only the property owner can transfer history" });

      const existingTransfer = await db.select()
        .from(propertyTransfers)
        .where(and(
          eq(propertyTransfers.propertyId, property.id),
          eq(propertyTransfers.status, "pending")
        ));

      if (existingTransfer.length > 0) {
        return res.status(400).json({ error: "A pending transfer already exists for this property" });
      }

      const claimToken = crypto.randomBytes(32).toString("hex");

      const [transfer] = await db.insert(propertyTransfers).values({
        propertyId: property.id,
        fromUserId: userId,
        toEmail: buyerEmail,
        claimToken,
        status: "pending",
        createdAt: new Date().toISOString(),
      }).returning();

      const fromName = [user.firstName, user.lastName].filter(Boolean).join(" ") || "An UpTend user";

      const emailResult = await sendPropertyTransferEmail(
        buyerEmail,
        fromName,
        property.fullAddress || "your new property",
        claimToken,
        property.maintenanceScore || 0
      );

      await logAuditEvent({
        action: "property_transfer_initiated",
        resourceType: "property",
        resourceId: property.id,
        userId,
        details: { toEmail: buyerEmail.replace(/(.{2}).*@/, "$1***@"), transferId: transfer.id },
      });

      res.json({ 
        transfer, 
        emailSent: emailResult.success,
        message: emailResult.success 
          ? `Transfer invitation sent to ${buyerEmail}` 
          : "Transfer created but email delivery failed. Share the claim link manually."
      });
    } catch (error) {
      console.error("Error initiating property transfer:", error);
      res.status(500).json({ error: "Failed to initiate transfer" });
    }
  });

  // ==========================================
  // PROPERTY TRANSFER: View claim details (public - no auth required)
  // ==========================================
  app.get("/api/properties/claim/:token", async (req, res) => {
    try {
      const [transfer] = await db.select()
        .from(propertyTransfers)
        .where(eq(propertyTransfers.claimToken, req.params.token));

      if (!transfer) return res.status(404).json({ error: "Transfer not found or expired" });

      if (transfer.status !== "pending") {
        return res.status(400).json({ error: "This transfer has already been claimed", status: transfer.status });
      }

      const [property] = await db.select()
        .from(properties)
        .where(eq(properties.id, transfer.propertyId!));

      if (!property) return res.status(404).json({ error: "Property not found" });

      const events = await db.select()
        .from(propertyEvents)
        .where(eq(propertyEvents.propertyId, property.id));

      res.json({
        address: property.fullAddress,
        maintenanceScore: property.maintenanceScore,
        estimatedValueIncrease: property.estimatedValueIncrease,
        eventCount: events.length,
        events: events.map(e => ({
          type: e.eventType,
          description: e.description,
          date: e.date,
          verifiedBy: e.verifiedBy,
        })),
        toEmail: transfer.toEmail,
        createdAt: transfer.createdAt,
      });
    } catch (error) {
      console.error("Error viewing claim:", error);
      res.status(500).json({ error: "Failed to load claim" });
    }
  });

  // ==========================================
  // PROPERTY TRANSFER: Claim property history (buyer accepts)
  // ==========================================
  app.post("/api/properties/claim/:token", async (req, res) => {
    try {
      const { email, firstName, lastName } = req.body;

      const [transfer] = await db.select()
        .from(propertyTransfers)
        .where(eq(propertyTransfers.claimToken, req.params.token));

      if (!transfer) return res.status(404).json({ error: "Transfer not found or expired" });
      if (transfer.status !== "pending") {
        return res.status(400).json({ error: "This transfer has already been claimed" });
      }

      const claimEmail = email || transfer.toEmail;

      let existingUser = await storage.getUserByEmail(claimEmail);

      if (!existingUser) {
        existingUser = await storage.createUser({
          email: claimEmail,
          firstName: firstName || "",
          lastName: lastName || "",
          role: "customer",
          password: crypto.randomBytes(16).toString("hex"),
        });
      }

      await db.update(propertyTransfers)
        .set({
          status: "claimed",
          claimedByUserId: existingUser.id,
          claimedAt: new Date().toISOString(),
        })
        .where(eq(propertyTransfers.id, transfer.id));

      await db.update(properties)
        .set({ ownerId: existingUser.id })
        .where(eq(properties.id, transfer.propertyId!));

      await logAuditEvent({
        action: "property_transfer_claimed",
        resourceType: "property",
        resourceId: transfer.propertyId || "",
        userId: existingUser.id,
        details: { transferId: transfer.id, fromUserId: transfer.fromUserId },
      });

      res.json({ 
        success: true, 
        message: "Property history claimed successfully! You are now the verified owner.",
        isNewUser: !email,
      });
    } catch (error) {
      console.error("Error claiming property:", error);
      res.status(500).json({ error: "Failed to claim property" });
    }
  });

  // ==========================================
  // HOME SCORE (Gamified Property Score)
  // ==========================================

  app.get("/api/home-score", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const scoreData = await getHomeScore(userId);
      const label = getScoreLabel(scoreData.totalScore || 0);
      const percentile = getScorePercentile(scoreData.totalScore || 0);

      res.json({
        ...scoreData,
        label,
        percentile,
      });
    } catch (error) {
      console.error("Error fetching home score:", error);
      res.status(500).json({ error: "Failed to fetch home score" });
    }
  });

  app.post("/api/home-score/boost", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const newScore = await updateHomeScore(userId, "home_consultation", "manual-boost");
      res.json({ success: true, newScore });
    } catch (error) {
      console.error("Error boosting home score:", error);
      res.status(500).json({ error: "Failed to boost score" });
    }
  });

  // ==========================================
  // CONSULTATIONS ($49 Commitment Credit)
  // ==========================================

  app.post("/api/consultations", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const { scheduledAt } = req.body;
      const consultation = await storage.createConsultation({
        customerId: userId,
        status: "scheduled",
        price: 4900,
        scheduledAt: scheduledAt || new Date().toISOString(),
      });

      res.json(consultation);
    } catch (error) {
      console.error("Error creating consultation:", error);
      res.status(500).json({ error: "Failed to create consultation" });
    }
  });

  app.get("/api/consultations", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const consultationsList = await storage.getConsultationsByCustomer(userId);
      res.json(consultationsList);
    } catch (error) {
      console.error("Error fetching consultations:", error);
      res.status(500).json({ error: "Failed to fetch consultations" });
    }
  });

  app.post("/api/consultations/:id/complete", requireAuth, async (req, res) => {
    try {
      const { recommendations } = req.body;
      const consultId = req.params.id;
      const userId = (req as any).user?.id;

      const consultation = await storage.getConsultation(consultId);
      if (!consultation) return res.status(404).json({ error: "Consultation not found" });

      await storage.updateConsultation(consultId, {
        status: "completed",
        completedAt: new Date().toISOString(),
        generatedTreatmentPlan: recommendations || [],
      });

      try {
        await updateHomeScore(consultation.customerId, "home_consultation", consultId);
      } catch (err) {
        console.error("Failed to update home score:", err);
      }

      if (recommendations && Array.isArray(recommendations)) {
        for (const rec of recommendations) {
          if (rec.deferred) {
            const nextNudge = new Date();
            nextNudge.setDate(nextNudge.getDate() + 30);
            await storage.createDeferredJob({
              userId: consultation.customerId,
              consultationId: consultId,
              title: rec.label || rec.title || "Maintenance Task",
              estimatedPrice: Math.round((rec.avgPrice || rec.price || 0) * 100),
              reasonForDeferral: rec.reason || "budget",
              nextNudgeDate: nextNudge.toISOString(),
              photoUrl: rec.photoUrl || null,
            });
          }
        }
      }

      res.json({ success: true, message: "Consultation completed" });
    } catch (error) {
      console.error("Error completing consultation:", error);
      res.status(500).json({ error: "Failed to complete consultation" });
    }
  });

  app.get("/api/consultations/credit", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const credit = await storage.getUnusedConsultationCredit(userId);
      res.json({ hasCredit: !!credit, credit });
    } catch (error) {
      res.status(500).json({ error: "Failed to check credit" });
    }
  });

  // ==========================================
  // INVENTORY (Digital Home / Auto-Inventory)
  // ==========================================

  app.get("/api/inventory", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const items = await storage.getHomeInventoryByCustomer(userId);
      const totalValue = items.reduce((sum, item) => sum + (item.estimatedValue || 0), 0);

      res.json({ items, totalValue, itemCount: items.length });
    } catch (error) {
      console.error("Error fetching inventory:", error);
      res.status(500).json({ error: "Failed to fetch inventory" });
    }
  });

  app.post("/api/inventory/scan", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const { photoUrls, consultationId } = req.body;
      if (!photoUrls || !Array.isArray(photoUrls) || photoUrls.length === 0) {
        return res.status(400).json({ error: "Photo URLs required" });
      }

      const items = await parseInventoryFromPhotos(photoUrls, userId, consultationId);
      res.json({ success: true, items, count: items.length });
    } catch (error) {
      console.error("Error scanning inventory:", error);
      res.status(500).json({ error: "Failed to scan inventory" });
    }
  });

  app.patch("/api/inventory/:id", requireAuth, async (req, res) => {
    try {
      const item = await storage.updateHomeInventoryItem(req.params.id, req.body);
      if (!item) return res.status(404).json({ error: "Item not found" });
      res.json(item);
    } catch (error) {
      res.status(500).json({ error: "Failed to update item" });
    }
  });

  // ==========================================
  // DEFERRED JOBS (Maintenance Plan / Nudge Engine)
  // ==========================================

  app.get("/api/deferred-jobs", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const jobs = await storage.getDeferredJobsByUser(userId);
      res.json(jobs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch deferred jobs" });
    }
  });

  app.post("/api/deferred-jobs", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const { title, estimatedPrice, reason, consultationId, photoUrl } = req.body;
      const nextNudge = new Date();
      nextNudge.setDate(nextNudge.getDate() + 30);

      const job = await storage.createDeferredJob({
        userId,
        consultationId,
        title,
        estimatedPrice: Math.round((estimatedPrice || 0) * 100),
        reasonForDeferral: reason || "budget",
        nextNudgeDate: nextNudge.toISOString(),
        photoUrl,
      });
      res.json(job);
    } catch (error) {
      res.status(500).json({ error: "Failed to create deferred job" });
    }
  });

  app.patch("/api/deferred-jobs/:id", requireAuth, async (req, res) => {
    try {
      const job = await storage.updateDeferredJob(req.params.id, req.body);
      if (!job) return res.status(404).json({ error: "Deferred job not found" });
      res.json(job);
    } catch (error) {
      res.status(500).json({ error: "Failed to update deferred job" });
    }
  });

  app.post("/api/deferred-jobs/:id/convert", requireAuth, async (req, res) => {
    try {
      const job = await storage.updateDeferredJob(req.params.id, {
        status: "converted",
      });
      if (!job) return res.status(404).json({ error: "Deferred job not found" });
      res.json({ success: true, message: "Job converted to active booking" });
    } catch (error) {
      res.status(500).json({ error: "Failed to convert job" });
    }
  });

  // ==========================================
  // HAULER CAREER LADDER
  // ==========================================

  app.get("/api/hauler/career", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const profile = await storage.getHaulerProfile(userId);
      if (!profile) return res.status(404).json({ error: "Hauler profile not found" });

      const careerStats = await storage.getHaulerCareerStats(profile.id);
      const nextLevel = getNextLevelRequirements(careerStats.level);

      let progress = 0;
      if (careerStats.level === 1) {
        progress = Math.min(100, Math.round((careerStats.jobsCompleted / nextLevel.requirements.jobs) * 100));
      } else if (careerStats.level === 2) {
        const jobProgress = careerStats.jobsCompleted / (nextLevel.requirements as any).jobs;
        const starProgress = careerStats.fiveStarRatingCount / ((nextLevel.requirements as any).fiveStarCount || 40);
        progress = Math.min(100, Math.round(((jobProgress + starProgress) / 2) * 100));
      } else {
        progress = 100;
      }

      res.json({
        ...careerStats,
        levelName: LEVEL_NAMES[careerStats.level] || "Rookie Hauler",
        nextLevel,
        progress,
      });
    } catch (error) {
      console.error("Error fetching career stats:", error);
      res.status(500).json({ error: "Failed to fetch career stats" });
    }
  });

  app.get("/api/hauler/certifications", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const profile = await storage.getHaulerProfile(userId);
      if (!profile) return res.status(404).json({ error: "Hauler profile not found" });

      const certs = await storage.getHaulerCertifications(profile.id);
      res.json(certs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch certifications" });
    }
  });

  app.post("/api/hauler/check-promotion", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const profile = await storage.getHaulerProfile(userId);
      if (!profile) return res.status(404).json({ error: "Hauler profile not found" });

      const result = await checkPromotion(profile.id);
      if (result.promoted) {
        await addXp(profile.id, 100);
      }
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: "Failed to check promotion" });
    }
  });

  // ===== PYCKER Academy Certification (Legacy) =====
  app.post("/api/hauler/certify", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const profile = await storage.getHaulerProfile(userId);
      if (!profile) return res.status(404).json({ error: "Hauler profile not found" });

      if (profile.isCertified) {
        return res.json({ message: "Already certified", certified: true });
      }

      const { score, totalModules } = req.body;
      if (typeof score !== "number" || typeof totalModules !== "number" || score < totalModules) {
        return res.status(400).json({ error: "Must pass all modules" });
      }

      await db.update(haulerProfiles)
        .set({
          isCertified: true,
          certifiedAt: new Date().toISOString(),
          canAcceptJobs: true,
        })
        .where(eq(haulerProfiles.id, profile.id));

      await logAuditEvent(
        userId,
        "hauler",
        "hauler_certified",
        `hauler_profile:${profile.id}`,
        { score, totalModules }
      );

      res.json({ certified: true, message: "Certification complete. You can now receive jobs." });
    } catch (error) {
      console.error("Certification error:", error);
      res.status(500).json({ error: "Failed to complete certification" });
    }
  });

  // ===== PYCKER Academy Role-Based Certification =====
  const academyCertifySchema = z.object({
    skills: z.array(z.enum(["core_safety", "junk_removal", "pressure_washing", "gutter_cleaning", "moving_labor"])).min(1),
    scores: z.record(z.string(), z.number()).optional(),
  }).refine((data) => data.skills.includes("core_safety"), {
    message: "Core Safety certification is required",
  });

  app.post("/api/academy/certify", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const profile = await storage.getHaulerProfile(userId);
      if (!profile) return res.status(404).json({ error: "Hauler profile not found" });

      const parsed = academyCertifySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.issues.map((i) => i.message).join(", ") });
      }

      const { skills, scores } = parsed.data;

      const oneYearFromNow = new Date();
      oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);

      for (const skill of skills) {
        await db.insert(haulerCertifications).values({
          haulerId: profile.id,
          skillType: skill,
          type: skill,
          status: "active",
          isActive: true,
          earnedAt: new Date().toISOString(),
          expiresAt: oneYearFromNow.toISOString(),
          quizScore: scores?.[skill] || 100,
        });
      }

      const serviceSkillMap: Record<string, string> = {
        junk_removal: "junk_removal",
        pressure_washing: "pressure_washing",
        gutter_cleaning: "gutter_cleaning",
        moving_labor: "moving_labor",
      };
      const unlockedServices = skills
        .filter((s: string) => serviceSkillMap[s])
        .map((s: string) => serviceSkillMap[s]);

      const currentServices = (profile.supportedServices as string[]) || ["junk_removal"];
      const mergedServices = [...new Set([...currentServices, ...unlockedServices])];

      const xpGain = skills.length * 50;

      await db.update(haulerProfiles)
        .set({
          isCertified: true,
          certifiedAt: new Date().toISOString(),
          canAcceptJobs: true,
          supportedServices: mergedServices,
          xpPoints: (profile.xpPoints || 0) + xpGain,
        })
        .where(eq(haulerProfiles.id, profile.id));

      const tierUp = skills.length >= 3;
      if (tierUp) {
        await db.update(haulerProfiles)
          .set({ pyckerTier: "verified_pro", payoutPercentage: 0.80 })
          .where(eq(haulerProfiles.id, profile.id));
      }

      await logAuditEvent(
        userId,
        "hauler",
        "academy_certified",
        `hauler_profile:${profile.id}`,
        { skills, scores, xpGain, tierUp }
      );

      res.json({
        certified: true,
        skills,
        unlockedServices: mergedServices,
        xpGained: xpGain,
        tierUp,
        message: "Certification complete. Your badges are now active.",
      });
    } catch (error) {
      console.error("Academy certification error:", error);
      res.status(500).json({ error: "Failed to complete certification" });
    }
  });

  // ===== Job Status Update (for Job Wizard) =====
  app.patch("/api/service-requests/:id/status", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const { id } = req.params;
      const { status, elapsedSeconds, upyckJobs, referrals, results } = req.body;

      const request = await storage.getServiceRequest(id);
      if (!request) return res.status(404).json({ error: "Service request not found" });

      const updateData: Record<string, unknown> = { status };

      if (status === "en_route") {
        updateData.acceptedAt = new Date().toISOString();
      } else if (status === "arrived") {
        updateData.arrivedAt = new Date().toISOString();
      } else if (status === "working") {
        updateData.startedAt = new Date().toISOString();
      } else if (status === "completed") {
        updateData.completedAt = new Date().toISOString();

        if (elapsedSeconds && request.serviceType === "moving_labor") {
          const hours = elapsedSeconds / 3600;
          const crewSize = request.laborCrewSize || 1;
          const rate = 45;
          updateData.finalPrice = Math.round(hours * rate * crewSize * 100) / 100;
          updateData.laborHours = Math.ceil(hours * 4) / 4;
        }

        const profile = await storage.getHaulerProfile(userId);
        if (profile) {
          const newRookieCount = (profile.rookieJobsCompleted || 0) + 1;
          const updateHauler: Record<string, unknown> = {
            rookieJobsCompleted: newRookieCount,
          };
          if (newRookieCount >= 3 && profile.isRookieMode) {
            updateHauler.isRookieMode = false;
          }
          await db.update(haulerProfiles)
            .set(updateHauler)
            .where(eq(haulerProfiles.id, profile.id));
        }
      }

      await db.update(serviceRequests)
        .set(updateData)
        .where(eq(serviceRequests.id, id));

      await logAuditEvent(
        userId,
        "hauler",
        `job_status_${status}`,
        `service_request:${id}`,
        { status, elapsedSeconds, hasReferrals: !!referrals }
      );

      const updated = await storage.getServiceRequest(id);
      res.json(updated);
    } catch (error) {
      console.error("Status update error:", error);
      res.status(500).json({ error: "Failed to update job status" });
    }
  });

  // ===== Get single service request =====
  app.get("/api/service-requests/:id", requireAuth, async (req, res) => {
    try {
      const request = await storage.getServiceRequest(req.params.id);
      if (!request) return res.status(404).json({ error: "Service request not found" });
      res.json(request);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch service request" });
    }
  });

  return httpServer;
}

function optimizeRoute(jobs: any[]): any[] {
  const jobsWithCoords = jobs.filter(j => j.pickupLat && j.pickupLng);
  const jobsWithoutCoords = jobs.filter(j => !j.pickupLat || !j.pickupLng);

  if (jobsWithCoords.length <= 1) {
    return [...jobsWithCoords, ...jobsWithoutCoords];
  }

  const visited = new Set<number>();
  const optimized: any[] = [];
  let current = 0;
  visited.add(0);
  optimized.push(jobsWithCoords[0]);

  while (visited.size < jobsWithCoords.length) {
    let nearestIdx = -1;
    let nearestDist = Infinity;

    for (let i = 0; i < jobsWithCoords.length; i++) {
      if (visited.has(i)) continue;
      const dist = haversineDistance(
        jobsWithCoords[current].pickupLat,
        jobsWithCoords[current].pickupLng,
        jobsWithCoords[i].pickupLat,
        jobsWithCoords[i].pickupLng
      );
      if (dist < nearestDist) {
        nearestDist = dist;
        nearestIdx = i;
      }
    }

    if (nearestIdx >= 0) {
      visited.add(nearestIdx);
      optimized.push(jobsWithCoords[nearestIdx]);
      current = nearestIdx;
    }
  }

  return [...optimized, ...jobsWithoutCoords];
}

function haversineDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const R = 3958.8;
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLng = ((lng2 - lng1) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
